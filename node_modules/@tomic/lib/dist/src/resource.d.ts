import { Agent } from './agent.js';
import { Collection } from './collection.js';
import { Commit } from './commit.js';
import { InferTypeOfValueInTriple, OptionalClass, QuickAccesPropType } from './ontology.js';
import { Store } from './store.js';
import { JSONValue, JSONArray } from './value.js';

/** Contains the PropertyURL / Value combinations */
export type PropVals = Map<string, JSONValue>;
/**
 * If a resource has no subject, it will have this subject. This means that the
 * Resource is not saved or fetched.
 */
export declare const unknownSubject = "unknown-subject";
export declare enum ResourceEvents {
    LocalChange = "local-change"
}
type ResourceEventHandlers = {
    [ResourceEvents.LocalChange]: (prop: string, value: JSONValue) => void;
};
/**
 * Describes an Atomic Resource, which has a Subject URL and a bunch of Property
 * / Value combinations.
 *
 * Create new resources using `store.createResource()`.
 */
export declare class Resource<C extends OptionalClass = any> {
    /** If the resource could not be fetched, we put that info here. */
    error?: Error;
    /** If the commit could not be saved, we put that info here. */
    commitError?: Error;
    /** Is true for locally created, unsaved resources */
    new: boolean;
    /**
     * Is true when the Resource is currently being fetched, awaiting a response
     * from the Server
     */
    loading: boolean;
    /**
     * Every commit that has been applied should be stored here, which prevents
     * applying the same commit twice
     */
    appliedCommitSignatures: Set<string>;
    readonly __internalObject: this;
    private commitBuilder;
    private _subject;
    private propvals;
    private inProgressCommit;
    private hasQueue;
    private _store?;
    private eventManager;
    constructor(subject: string, newResource?: boolean);
    /** The subject URL of the resource */
    get subject(): string;
    /** A human readable title for the resource, returns first of eighter: name, shortname, filename or subject */
    get title(): string;
    /**
     * Dynamic prop accessor, only works for known properties registered via an ontology.
     * @example const description = resource.props.description
     */
    get props(): QuickAccesPropType<C>;
    private get store();
    on<T extends ResourceEvents>(event: T, callback: ResourceEventHandlers[T]): () => void;
    /** @internal */
    setStore(store: Store): void;
    /** Checks if the content of two Resource instances is equal */
    equals(resourceB: Resource): boolean;
    /** Checks if the agent has write rights by traversing the graph. Recursive function. */
    canWrite(agent?: string, child?: string): Promise<[boolean, string | undefined]>;
    /**
     * Creates a clone of the Resource, which makes sure the reference is
     * different from the previous one. This can be useful when doing reference compares.
     */
    clone(): Resource<C>;
    /** Checks if the resource is both loaded and free from errors */
    isReady(): boolean;
    /** Get a Value by its property
     * @param propUrl The subject of the property
     * @example
     * import { core } from '@tomic/lib'
     * const description = resource.get(core.properties.description)
     * const publishedAt = resource.get('https://my-atomicserver.dev/properties/published-at')
     */
    get<Prop extends string, Returns = InferTypeOfValueInTriple<C, Prop>>(propUrl: Prop): Returns;
    /**
     * Get a Value by its property, returns as Array with subjects instead of the
     * full resource or throws error. Returns empty array if there is no value
     */
    getSubjects(propUrl: string): string[];
    /**
     * Get a Value by its property, returns as Array or throws error. Returns
     * empty array if there is no value
     */
    getArray(propUrl: string): JSONArray;
    /** Returns a list of classes of this resource */
    getClasses(): string[];
    /** Checks if the resource is all of the given classes */
    hasClasses(...classSubjects: string[]): boolean;
    /**
     * `.matchClass()` takes an object that maps class subjects to values.
     * If the resource has a class that is a key in the object, the corresponding value is returned.
     * An optional fallback value can be provided as the second argument.
     * The order of the classes in the object is important, as the first match is returned.
     */
    matchClass<T>(obj: Record<string, T>): T | undefined;
    matchClass<T>(obj: Record<string, T>, fallback: T): T;
    /** Remove the given classes from the resource */
    removeClasses(...classSubjects: string[]): void;
    /** Adds the given classes to the resource */
    addClasses(...classSubject: string[]): Promise<void>;
    /** Returns true if the resource has changes in it's commit builder that are not yet saved to the server. */
    hasUnsavedChanges(): boolean;
    getCommitsCollectionSubject(): string;
    /** Returns a Collection with all children of this resource
     * @param pageSize The amount of children per page (default: 100)
     */
    getChildrenCollection(pageSize?: number): Promise<Collection>;
    /** builds all versions using the Commits */
    getHistory(progressCallback?: (percentage: number) => void): Promise<Version[]>;
    setVersion(version: Version): Promise<void>;
    /**
     * @deprecated use resource.subject
     */
    getSubject(): string;
    /** Returns the subject URL of the Resource */
    getSubjectNoParams(): string;
    /** Returns the internal Map of Property-Values */
    getPropVals(): PropVals;
    /**
     * Iterates over the parents of the resource, returns who has read / write
     * rights for this resource
     */
    getRights(): Promise<Right[]>;
    /** Returns true is the resource had an `Unauthorized` 401 response. */
    isUnauthorized(): boolean;
    /** Removes the resource form both the server and locally */
    destroy(agent?: Agent): Promise<void>;
    /** @deprecated use `resource.push` */
    pushPropVal(propUrl: string, values: JSONArray, unique?: boolean): void;
    /** Appends a Resource to a ResourceArray */
    push(propUrl: string, values: JSONArray, unique?: boolean): void;
    /** @deprecated use `resource.remove()` */
    removePropVal(propertyUrl: string): void;
    /** Removes a property value combination from the resource and adds it to the next Commit */
    remove(propertyUrl: string): void;
    /**
     * Removes a property value combination from this resource, does not store the
     * remove action in Commit
     */
    removePropValLocally(propertyUrl: string): void;
    /**
     * Commits the changes and sends the Commit to the resource's `/commit`
     * endpoint. Returns the Url of the created Commit. If you don't pass an Agent
     * explicitly, the default Agent of the Store is used.
     * When there are no changes no commit is made and the function returns Promise<undefined>.
     */
    save(differentAgent?: Agent): Promise<string | undefined>;
    /**
     * Set a Property, Value combination and perform a validation. Will throw if
     * property is not valid for the datatype. Will fetch the datatype if it's not
     * available. Adds the property to the commitbuilder.
     *
     * When undefined is passed as value, the property is removed from the resource.
     */
    set<Prop extends string, Value extends InferTypeOfValueInTriple<C, Prop>>(prop: Prop, value: Value, 
    /**
     * Disable validation if you don't need it. It might cause a fetch if the
     * Property is not present when set is called
     */
    validate?: boolean): Promise<void>;
    /**
     * Set a Property, Value combination without performing validations or adding
     * it to the CommitBuilder.
     */
    setUnsafe(prop: string, val: JSONValue): void;
    /** Sets the error on the Resource. Does not Throw. */
    setError(e: Error): void;
    /** Set the Subject / ID URL of the Resource. Does not update the Store. */
    setSubject(subject: string): void;
    /** Refetches the resource from the server. Will reset all changes to the latest saved version */
    refresh(): Promise<void>;
    private isParentNew;
}
/** Type of Rights (e.g. read or write) */
export declare enum RightType {
    /** Open a resource or its children */
    READ = "read",
    /** Edit or delete a resource or its children */
    WRITE = "write"
}
/** A grant / permission that is set somewhere */
export interface Right {
    /** Subject of the Agent who the right is for */
    for: string;
    /** The resource that has set the Right */
    setIn: string;
    /** Type of right (e.g. read / write) */
    type: RightType;
}
export interface Version {
    commit: Commit;
    resource: Resource;
}
export declare function proxyResource<C extends OptionalClass = any>(resource: Resource<C>): Resource<C>;
export {};
//# sourceMappingURL=resource.d.ts.map