import { Resource } from './resource.js';
import { Store } from './store.js';
import { JSONValue, JSONArray } from './value.js';

/** A {@link Commit} without its signature, signer and timestamp */
export interface CommitBuilderI {
    /** The resource being edited */
    subject: string;
    /** The property-value combinations being edited https://atomicdata.dev/properties/set */
    set?: Record<string, JSONValue>;
    /**
     * The property-value combinations for which one or more ResourceArrays will
     * be appended. https://atomicdata.dev/properties/push
     */
    push?: Record<string, JSONArray>;
    /** The properties that need to be removed. https://atomicdata.dev/properties/remove */
    remove?: string[];
    /** If true, the resource must be deleted. https://atomicdata.dev/properties/destroy */
    destroy?: boolean;
    /**
     * URL of the previous Commit, used by the receiver to make sure that we're
     * having the same current version.
     */
    previousCommit?: string;
}
interface CommitBuilderBase {
    set?: Map<string, JSONValue>;
    push?: Map<string, Set<JSONValue>>;
    remove?: Set<string>;
    destroy?: boolean;
    previousCommit?: string;
}
/** Return the current time as Atomic Data timestamp. Milliseconds since unix epoch. */
export declare function getTimestampNow(): number;
/** A {@link Commit} without its signature, signer and timestamp */
export declare class CommitBuilder {
    private _subject;
    private _set;
    private _push;
    private _remove;
    private _destroy?;
    private _previousCommit?;
    /** Removes any query parameters from the Subject */
    constructor(subject: string, base?: CommitBuilderBase);
    get subject(): string;
    get set(): Map<string, JSONValue>;
    get push(): Map<string, Set<JSONValue>>;
    get remove(): Set<string>;
    get destroy(): boolean | undefined;
    get previousCommit(): string | undefined;
    addSetAction(property: string, value: JSONValue): CommitBuilder;
    addPushAction(property: string, ...values: JSONArray): CommitBuilder;
    addRemoveAction(property: string): CommitBuilder;
    removeRemoveAction(property: string): CommitBuilder;
    setDestroy(destroy: boolean): CommitBuilder;
    /**
     * Set the URL of the Commit that was previously (last) applied. The value of
     * this should probably be the `lastCommit` of the Resource.
     */
    setPreviousCommit(prev: string): CommitBuilder;
    setSubject(subject: string): CommitBuilder;
    /**
     * Signs the commit using the privateKey of the Agent, and returns a full
     * Commit which is ready to be sent to an Atomic-Server `/commit` endpoint.
     */
    sign(privateKey: string, agentSubject: string): Promise<Commit>;
    /** Returns true if the CommitBuilder has non-empty changes (set, remove, destroy) */
    hasUnsavedChanges(): boolean;
    /**
     * Creates a clone of the CommitBuilder. This is required, because I want to
     * prevent any adjustments to the CommitBuilder while signing, as this could
     * cause race conditions with wrong signatures
     */
    clone(): CommitBuilder;
    toPlainObject(): CommitBuilderI;
    /** Creates a signature for a Commit using the private Key of some Agent. */
    signAt(
    /** Subject URL of the Agent signing the Commit */
    agent: string, 
    /** Base64 serialized private key matching the public key of the agent */
    privateKey: string, 
    /** Time of signing in millisecons since unix epoch */
    createdAt: number): Promise<Commit>;
}
/** A {@link Commit} without its signature, but with a signer and timestamp */
interface CommitPreSigned extends CommitBuilderI {
    /** https://atomicdata.dev/properties/signer */
    signer: string;
    /** Unix timestamp in milliseconds, see https://atomicdata.dev/properties/createdAt */
    createdAt: number;
}
/**
 * A Commit represents a (set of) changes to one specific Resource. See
 * https://atomicdata.dev/classes/Commit If you want to create a Commit, you
 * should probably use the {@link CommitBuilder} and call `.sign()` on it.
 */
export interface Commit extends CommitPreSigned {
    /** https://atomicdata.dev/properties/signature */
    signature: string;
    /**
     * Subject of created Commit. Will only be present after it was accepted and
     * applied by the Server.
     */
    id?: string;
}
/**
 * Takes a commit and serializes it deterministically (canonicilaization). Is
 * used both for signing Commits as well as serializing them.
 * https://docs.atomicdata.dev/core/json-ad.html#canonicalized-json-ad
 */
export declare function serializeDeterministically(commit: CommitPreSigned | Commit): string;
/**
 * Signs a string using a base64 encoded ed25519 private key. Outputs a base64
 * encoded ed25519 signature
 */
export declare const signToBase64: (message: string, privateKeyBase64: string) => Promise<string>;
/** From base64 encoded private key */
export declare const generatePublicKeyFromPrivate: (privateKey: string) => Promise<string>;
interface KeyPair {
    publicKey: string;
    privateKey: string;
}
export declare function generateKeyPair(): Promise<KeyPair>;
export declare function parseCommitResource(resource: Resource): Commit;
export declare function parseCommitJSON(str: string): Commit;
/** Applies a commit, but does not modify the store */
export declare function applyCommitToResource(resource: Resource, commit: Commit): Resource;
/** Parses a JSON-AD Commit, applies it and adds it (and nested resources) to the store. */
export declare function parseAndApplyCommit(jsonAdObjStr: string, store: Store): void;
export {};
//# sourceMappingURL=commit.d.ts.map