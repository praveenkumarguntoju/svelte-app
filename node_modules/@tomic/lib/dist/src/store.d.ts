import { Agent } from './agent.js';
import { FileOrFileLike } from './client.js';
import { Commit } from './commit.js';
import { Datatype } from './datatypes.js';
import { Server } from './ontologies/server.js';
import { OptionalClass, UnknownClass } from './ontology.js';
import { Resource } from './resource.js';
import { SearchOpts } from './search.js';
import { JSONValue } from './value.js';

/** Function called when a resource is updated or removed */
type ResourceCallback<C extends OptionalClass = UnknownClass> = (resource: Resource<C>) => void;
/** Callback called when the stores agent changes */
type AgentCallback = (agent: Agent | undefined) => void;
type ErrorCallback = (e: Error) => void;
type ServerURLCallback = (serverURL: string) => void;
type Fetch = typeof fetch;
type AddResourcesOpts = {
    skipCommitCompare?: boolean;
};
type CreateResourceOptions = {
    /** Optional subject of the new resource, if not given the store will generate a random subject */
    subject?: string;
    /** Parent the subject belongs to, defaults to the serverUrl */
    parent?: string;
    /** Set to true if the resource should not have a parent. (For example Drives don't have parents) */
    noParent?: boolean;
    /** Subject(s) of the resources class */
    isA?: string | string[];
    /** Any additional properties the resource should have */
    propVals?: Record<string, JSONValue>;
};
export interface StoreOpts {
    /** The default store URL, where to send commits and where to create new instances */
    serverUrl?: string;
    /** Default Agent, used for signing commits. Is required for posting things. */
    agent?: Agent;
}
/** These Events trigger certain Handlers */
export declare enum StoreEvents {
    /**
     * Whenever `Resource.save()` is called, so only when the user of this library
     * performs a save action.
     */
    ResourceSaved = "resource-saved",
    /** User perform a Remove action */
    ResourceRemoved = "resource-removed",
    /**
     * User explicitly created a Resource through a conscious action, e.g. through
     * the SideBar.
     */
    ResourceManuallyCreated = "resource-manually-created",
    /** Event that gets called whenever the stores agent changes */
    AgentChanged = "agent-changed",
    /** Event that gets called whenever the server url changes */
    ServerURLChanged = "server-url-changed",
    /** Event that gets called whenever the store encounters an error */
    Error = "error"
}
export interface ImportJsonADOptions {
    /** Where the resources will be imported to  */
    parent: string;
    /** Danger: Replaces Resources with matching subjects, even if they are not Children of the specified Parent. */
    overwriteOutside?: boolean;
}
/**
 * Handlers are functions that are called when a certain event occurs.
 */
type StoreEventHandlers = {
    [StoreEvents.ResourceSaved]: ResourceCallback;
    [StoreEvents.ResourceRemoved]: ResourceCallback;
    [StoreEvents.ResourceManuallyCreated]: ResourceCallback;
    [StoreEvents.AgentChanged]: AgentCallback;
    [StoreEvents.ServerURLChanged]: ServerURLCallback;
    [StoreEvents.Error]: ErrorCallback;
};
/**
 * An in memory store that has a bunch of usefful methods for retrieving Atomic
 * Data Resources. It is also resposible for keeping the Resources in sync with
 * Subscribers (components that use the Resource), and for managing the current
 * Agent (User).
 */
export declare class Store {
    /** A list of all functions that need to be called when a certain resource is updated */
    subscribers: Map<string, Array<ResourceCallback>>;
    private injectedFetch;
    /**
     * The base URL of an Atomic Server. This is where to send commits, create new
     * instances, search, etc.
     */
    private serverUrl;
    /** All the resources of the store */
    private _resources;
    /** List of resources that have parents that are not saved to the server, when a parent is saved it should also save its children */
    private batchedResources;
    /** Current Agent, used for signing commits. Is required for posting things. */
    private agent?;
    /** Mapped from origin to websocket */
    private webSockets;
    private eventManager;
    private client;
    constructor(opts?: StoreOpts);
    /** All the resources of the store */
    get resources(): Map<string, Resource>;
    /** Inject a custom fetch implementation to use when fetching resources over http */
    injectFetch(fetchOverride: Fetch): void;
    addResources(resources: Resource | Resource[], opts?: AddResourcesOpts): void;
    /**
     * @deprecated Will be marked private in the future, please use `addResources`
     *
     * Adds a Resource to the store and notifies subscribers. Replaces existing
     * resources, unless this new resource is explicitly incomplete.
     */
    addResource(resource: Resource, { skipCommitCompare }: AddResourcesOpts): void;
    /**
     * A helper function for creating new resources.
     * Options take:
     * subject (optional) - defaults to random subject,
     * parent (optional) - defaults to serverUrl,
     * isA (optional),
     * properties (optional) - any additional properties to be set on the resource.
     */
    newResource<C extends OptionalClass = UnknownClass>({ subject, parent, isA, propVals, noParent, }?: CreateResourceOptions): Promise<Resource<C>>;
    search(query: string, opts?: SearchOpts): Promise<string[]>;
    /** Checks if a subject is free to use */
    checkSubjectTaken(subject: string): Promise<boolean>;
    /**
     * Checks is a set of URL parts can be combined into an available subject.
     * Will retry until it works.
     */
    buildUniqueSubjectFromParts(parts: string[], parent?: string): Promise<string>;
    /** Creates a random subject url. You can pass a parent subject if you want that to be included in the url. */
    createSubject(parentSubject?: string): string;
    /**
     * Always fetches resource from the server then adds it to the store.
     */
    fetchResourceFromServer<C extends OptionalClass = UnknownClass>(
    /** The resource URL to be fetched */
    subject: string, opts?: {
        /**
         * Fetch it from the `/path` endpoint of your server URL. This effectively
         * is a proxy / cache.
         */
        fromProxy?: boolean;
        /** Overwrites the existing resource and sets it to loading. */
        setLoading?: boolean;
        /** Do not use WebSockets, use HTTP(S) */
        noWebSocket?: boolean;
        /** HTTP Method, defaults to GET */
        method?: 'GET' | 'POST';
        /** HTTP Body for POSTing */
        body?: ArrayBuffer | string;
    }): Promise<Resource<C>>;
    getAllSubjects(): string[];
    /** Returns the WebSocket for the current Server URL */
    getDefaultWebSocket(): WebSocket | undefined;
    /** Opens a Websocket for some subject URL, or returns the existing one. */
    getWebSocketForSubject(subject: string): WebSocket | undefined;
    /** Returns the base URL of the companion server */
    getServerUrl(): string;
    /**
     * Returns the Currently set Agent, returns null if there is none. Make sure
     * to first run `store.setAgent()`.
     */
    getAgent(): Agent | undefined;
    /**
     * Gets a resource by URL. Fetches and parses it if it's not available in the
     * store. Instantly returns an empty loading resource, while the fetching is
     * done in the background . If the subject is undefined, an empty non-saved
     * resource will be returned.
     */
    getResourceLoading<C extends OptionalClass = UnknownClass>(subject?: string, opts?: FetchOpts): Resource<C>;
    /**
     * @deprecated
     * renamed to `getResource`
     */
    getResourceAsync<C extends OptionalClass = UnknownClass>(subject: string): Promise<Resource<C>>;
    /**
     * Gets a resource by URL. Fetches and parses it if it's not available in the
     * store. Not recommended to use this for rendering, because it might cause
     * resources to be fetched multiple times.
     */
    getResource<C extends OptionalClass = UnknownClass>(subject: string): Promise<Resource<C>>;
    /** Gets a property by URL. */
    getProperty(subject: string): Promise<Property>;
    /**
     * This is called when Errors occur in some of the library functions.
     */
    notifyError(e: Error | string): void;
    /**
     * If the store does not have an active internet connection, will return
     * false. This may affect some functionality. For example, some checks will
     * not be performed client side when offline.
     */
    isOffline(): boolean;
    notifyResourceSaved(resource: Resource): Promise<void>;
    notifyResourceManuallyCreated(resource: Resource): Promise<void>;
    /** Parses the HTML document for `JSON-AD` data in <meta> tags, adds it to the store */
    parseMetaTags(): void;
    /**
     * Fetches all Classes and Properties from your current server, including external resources.
     * This helps to speed up time to interactive, but may not be necessary for all applications.
     */
    preloadPropsAndClasses(): Promise<void>;
    /** Sends an HTTP POST request to the server to the Subject. Parses the returned Resource and adds it to the store. */
    postToServer<R extends OptionalClass = Server.EndpointResponse>(url: string, data?: ArrayBuffer | string): Promise<Resource<R>>;
    /** Removes (destroys / deletes) resource from this store */
    removeResource(subject: string): void;
    /**
     * Changes the Subject of a Resource. Checks if the new name is already taken,
     * errors if so.
     */
    renameSubject(resource: Resource, newSubject: string): Promise<void>;
    /**
     * Sets the current Agent, used for signing commits. Authenticates all open
     * websockets, and retries previously failed fetches.
     *
     * Warning: doing this stores the Private Key of the Agent in memory. This
     * might have security implications for your application.
     */
    setAgent(agent: Agent | undefined): void;
    /** Sets the Server base URL, without the trailing slash. */
    setServerUrl(url: string): void;
    /** Opens a WebSocket for this Atomic Server URL */
    openWebSocket(url: string): void;
    /**
     * Registers a callback for when the a resource is updated. When you call
     * this
     * The method returns a function that you can call to unsubscribe. You can also unsubscribe by calling `store.unsubscribe()`.
     */
    subscribe(subject: string, callback: ResourceCallback): () => void;
    subscribeWebSocket(subject: string): void;
    unSubscribeWebSocket(subject: string): void;
    /** Unregisters the callback (see `subscribe()`) */
    unsubscribe(subject: string, callback: ResourceCallback): void;
    on<T extends StoreEvents>(event: T, callback: StoreEventHandlers[T]): () => void;
    /** Uploads files to atomic server and create resources for them, then returns the subjects.
     * If using this in Node.js and it does not work, try injecting node-fetch using `Store.injectFetch()` Some versions of Node create mallformed FormData when using the build-in fetch.
     */
    uploadFiles(files: FileOrFileLike[], parent: string): Promise<string[]>;
    /** Posts a Commit to some endpoint. Returns the Commit created by the server. */
    postCommit(commit: Commit, endpoint: string): Promise<Commit>;
    /**
     * Returns the ancestry of a resource, starting with the resource itself.
     */
    getResourceAncestry(resource: Resource): Promise<string[]>;
    /**
     * Returns a list of resources currently in the store which pass the given filter function.
     * This is a client-side filter, and does not query the server.
     */
    clientSideQuery(filter: (resource: Resource) => boolean): Resource[];
    /**
     * @Internal
     * Add the resource to a batch that is saved when the parent is saved. Only gets saved when the parent is new.
     */
    batchResource(subject: string): void;
    /**
     * @Internal
     * Saves all resources that are in a batch for a parent.
     */
    saveBatchForParent(subject: string): Promise<void>;
    importJsonAD(jsonADString: string, options: ImportJsonADOptions): Promise<void>;
    private randomPart;
    private findAvailableSubject;
    /** Lets subscribers know that a resource has been changed. Time to update your views.
     * Make sure the resource is a new reference, otherwise React will not rerender.
     */
    private notify;
}
/**
 * A Property represents a relationship between a Subject and its Value.
 * https://atomicdata.dev/classes/Property
 */
export interface Property {
    subject: string;
    /** https://atomicdata.dev/properties/datatype */
    datatype: Datatype;
    /** https://atomicdata.dev/properties/shortname */
    shortname: string;
    /** https://atomicdata.dev/properties/description */
    description: string;
    /** https://atomicdata.dev/properties/classType */
    classType?: string;
    /** If the Property cannot be found or parsed, this will contain the error */
    error?: Error;
    /** https://atomicdata.dev/properties/isDynamic */
    isDynamic?: boolean;
    /** When the Property is still awaiting a server response */
    loading?: boolean;
    allowsOnly?: string[];
}
export interface FetchOpts {
    /**
     * If this is true, incomplete resources will not be automatically fetched.
     * Incomplete resources are faster to process server-side, but they need to be
     * fetched again when all properties are needed.
     */
    allowIncomplete?: boolean;
    /** Do not fetch over WebSockets, always fetch over HTTP(S) */
    noWebSocket?: boolean;
    /**
     * If true, will not send a request to a server - it will simply create a new
     * local resource.
     */
    newResource?: boolean;
}
export {};
//# sourceMappingURL=store.d.ts.map