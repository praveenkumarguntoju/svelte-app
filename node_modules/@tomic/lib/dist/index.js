const gt = /* @__PURE__ */ new Map();
function Pe(...s) {
  for (const t of s) {
    for (const [e, r] of Object.entries(t.classes))
      gt.set(r, e);
    for (const [e, r] of Object.entries(t.properties))
      gt.set(r, e);
  }
}
function Ue(s) {
  return gt.get(s);
}
function ar() {
  return gt;
}
const A = {
  classes: {
    class: "https://atomicdata.dev/classes/Class",
    property: "https://atomicdata.dev/classes/Property",
    agent: "https://atomicdata.dev/classes/Agent",
    datatype: "https://atomicdata.dev/classes/Datatype",
    ontology: "https://atomicdata.dev/class/ontology"
  },
  properties: {
    allowsOnly: "https://atomicdata.dev/properties/allowsOnly",
    classtype: "https://atomicdata.dev/properties/classtype",
    datatype: "https://atomicdata.dev/properties/datatype",
    description: "https://atomicdata.dev/properties/description",
    incomplete: "https://atomicdata.dev/properties/incomplete",
    isA: "https://atomicdata.dev/properties/isA",
    isDynamic: "https://atomicdata.dev/properties/isDynamic",
    name: "https://atomicdata.dev/properties/name",
    parent: "https://atomicdata.dev/properties/parent",
    read: "https://atomicdata.dev/properties/read",
    recommends: "https://atomicdata.dev/properties/recommends",
    requires: "https://atomicdata.dev/properties/requires",
    shortname: "https://atomicdata.dev/properties/shortname",
    write: "https://atomicdata.dev/properties/write",
    publicKey: "https://atomicdata.dev/properties/publicKey",
    instances: "https://atomicdata.dev/properties/instances",
    properties: "https://atomicdata.dev/properties/properties",
    classes: "https://atomicdata.dev/properties/classes",
    isLocked: "https://atomicdata.dev/properties/isLocked",
    localId: "https://atomicdata.dev/properties/localId"
  }
}, Ot = {
  classes: {
    commit: "https://atomicdata.dev/classes/Commit"
  },
  properties: {
    subject: "https://atomicdata.dev/properties/subject",
    createdAt: "https://atomicdata.dev/properties/createdAt",
    lastCommit: "https://atomicdata.dev/properties/lastCommit",
    previousCommit: "https://atomicdata.dev/properties/previousCommit",
    signer: "https://atomicdata.dev/properties/signer",
    set: "https://atomicdata.dev/properties/set",
    push: "https://atomicdata.dev/properties/push",
    remove: "https://atomicdata.dev/properties/remove",
    destroy: "https://atomicdata.dev/properties/destroy",
    signature: "https://atomicdata.dev/properties/signature"
  }
}, Tt = {
  classes: {
    collection: "https://atomicdata.dev/classes/Collection"
  },
  properties: {
    members: "https://atomicdata.dev/properties/collection/members",
    currentPage: "https://atomicdata.dev/properties/collection/currentPage",
    pageSize: "https://atomicdata.dev/properties/collection/pageSize",
    property: "https://atomicdata.dev/properties/collection/property",
    totalMembers: "https://atomicdata.dev/properties/collection/totalMembers",
    totalPages: "https://atomicdata.dev/properties/collection/totalPages",
    value: "https://atomicdata.dev/properties/collection/value",
    sortBy: "https://atomicdata.dev/properties/collection/sortBy",
    sortDesc: "https://atomicdata.dev/properties/collection/sortDesc",
    includeExternal: "https://atomicdata.dev/properties/collection/includeExternal"
  }
}, _e = {
  classes: {
    article: "https://atomicdata.dev/classes/Article",
    bookmark: "https://atomicdata.dev/class/Bookmark",
    chatroom: "https://atomicdata.dev/classes/ChatRoom",
    currencyProperty: "https://atomicdata.dev/ontology/data-browser/class/currency-property",
    dateFormat: "https://atomicdata.dev/classes/DateFormat",
    displayStyle: "https://atomicdata.dev/class/DisplayStyle",
    document: "https://atomicdata.dev/classes/Document",
    floatRangeProperty: "https://atomicdata.dev/classes/FloatRangeProperty",
    folder: "https://atomicdata.dev/classes/Folder",
    formattedDate: "https://atomicdata.dev/classes/FormattedDate",
    formattedNumber: "https://atomicdata.dev/classes/FormattedNumber",
    importer: "https://atomicdata.dev/classes/Importer",
    message: "https://atomicdata.dev/classes/Message",
    numberFormat: "https://atomicdata.dev/classes/NumberFormat",
    paragraph: "https://atomicdata.dev/classes/elements/Paragraph",
    rangeProperty: "https://atomicdata.dev/classes/RangeProperty",
    selectProperty: "https://atomicdata.dev/classes/SelectProperty",
    table: "https://atomicdata.dev/classes/Table",
    tag: "https://atomicdata.dev/classes/Tag",
    template: "https://atomicdata.dev/ontology/data-browser/class/template"
  },
  properties: {
    color: "https://atomicdata.dev/properties/color",
    currency: "https://atomicdata.dev/ontology/data-browser/property/currency",
    customNodePositioning: "https://atomicdata.dev/properties/custom-node-positioning",
    dateFormat: "https://atomicdata.dev/properties/dateFormat",
    decimalPlaces: "https://atomicdata.dev/properties/decimalPlaces",
    displayStyle: "https://atomicdata.dev/property/display-style",
    elements: "https://atomicdata.dev/properties/documents/elements",
    emoji: "https://atomicdata.dev/properties/emoji",
    image: "https://atomicdata.dev/ontology/data-browser/property/image",
    imageUrl: "https://atomicdata.dev/properties/imageUrl",
    max: "https://atomicdata.dev/properties/max",
    maxFloat: "https://atomicdata.dev/properties/maxFloat",
    messages: "https://atomicdata.dev/properties/messages",
    min: "https://atomicdata.dev/properties/min",
    minFloat: "https://atomicdata.dev/properties/minFloat",
    nextPage: "https://atomicdata.dev/properties/nextPage",
    numberFormatting: "https://atomicdata.dev/properties/numberFormatting",
    preview: "https://atomicdata.dev/property/preview",
    publishedAt: "https://atomicdata.dev/properties/published-at",
    replyTo: "https://atomicdata.dev/properties/replyTo",
    resources: "https://atomicdata.dev/ontology/data-browser/property/resources",
    subResources: "https://atomicdata.dev/properties/subresources",
    tableColumnWidths: "https://atomicdata.dev/properties/tableColumnWidths",
    tags: "https://atomicdata.dev/properties/tags",
    url: "https://atomicdata.dev/property/url"
  }
}, wt = {
  classes: {
    error: "https://atomicdata.dev/classes/Error",
    endpoint: "https://atomicdata.dev/classes/Endpoint",
    drive: "https://atomicdata.dev/classes/Drive",
    redirect: "https://atomicdata.dev/classes/Redirect",
    file: "https://atomicdata.dev/classes/File",
    invite: "https://atomicdata.dev/classes/Invite",
    endpointResponse: "https://atomicdata.dev/ontology/server/class/endpoint-response"
  },
  properties: {
    drives: "https://atomicdata.dev/properties/drives",
    results: "https://atomicdata.dev/properties/endpoint/results",
    property: "https://atomicdata.dev/properties/search/property",
    redirectAgent: "https://atomicdata.dev/properties/invite/redirectAgent",
    agent: "https://atomicdata.dev/properties/invite/agent",
    publicKey: "https://atomicdata.dev/properties/invite/publicKey",
    target: "https://atomicdata.dev/properties/invite/target",
    usagesLeft: "https://atomicdata.dev/properties/invite/usagesLeft",
    users: "https://atomicdata.dev/properties/invite/users",
    write: "https://atomicdata.dev/properties/invite/write",
    filename: "https://atomicdata.dev/properties/filename",
    filesize: "https://atomicdata.dev/properties/filesize",
    downloadUrl: "https://atomicdata.dev/properties/downloadURL",
    mimetype: "https://atomicdata.dev/properties/mimetype",
    attachments: "https://atomicdata.dev/properties/attachments",
    createdBy: "https://atomicdata.dev/properties/createdBy",
    checksum: "https://atomicdata.dev/properties/checksum",
    internalId: "https://atomicdata.dev/properties/internalId",
    children: "https://atomicdata.dev/properties/children",
    parameters: "https://atomicdata.dev/properties/endpoint/parameters",
    destination: "https://atomicdata.dev/properties/destination",
    status: "https://atomicdata.dev/ontology/server/property/status",
    responseMessage: "https://atomicdata.dev/ontology/server/property/response-message",
    defaultOntology: "https://atomicdata.dev/ontology/server/property/default-ontology",
    imageWidth: "https://atomicdata.dev/properties/imageWidth",
    imageHeight: "https://atomicdata.dev/properties/imageHeight"
  }
};
function Ne() {
  Pe(A, Ot, Tt, _e, wt);
}
function ft() {
  return globalThis === globalThis.window;
}
const Be = {};
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const E = BigInt(0), g = BigInt(1), C = BigInt(2), re = BigInt(255), Kt = C ** BigInt(252) + BigInt("27742317777372353535851937790883648493"), R = {
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: C ** re - BigInt(19),
  l: Kt,
  n: Kt,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
}, oe = C ** BigInt(256), rt = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
const Oe = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), ke = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), Fe = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), Te = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
class w {
  constructor(t, e, r, o) {
    this.x = t, this.y = e, this.z = r, this.t = o;
  }
  static fromAffine(t) {
    if (!(t instanceof x))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return t.equals(x.ZERO) ? w.ZERO : new w(t.x, t.y, g, d(t.x * t.y));
  }
  static toAffineBatch(t) {
    const e = $e(t.map((r) => r.z));
    return t.map((r, o) => r.toAffine(e[o]));
  }
  static normalizeZ(t) {
    return this.toAffineBatch(t).map(this.fromAffine);
  }
  equals(t) {
    Gt(t);
    const { x: e, y: r, z: o } = this, { x: i, y: a, z: n } = t, c = d(e * n), p = d(i * o), u = d(r * n), h = d(a * o);
    return c === p && u === h;
  }
  negate() {
    return new w(d(-this.x), this.y, this.z, d(-this.t));
  }
  double() {
    const { x: t, y: e, z: r } = this, { a: o } = R, i = d(t ** C), a = d(e ** C), n = d(C * d(r ** C)), c = d(o * i), p = d(d((t + e) ** C) - i - a), u = c + a, h = u - n, l = c - a, f = d(p * h), m = d(u * l), y = d(p * l), S = d(h * u);
    return new w(f, m, S, y);
  }
  add(t) {
    Gt(t);
    const { x: e, y: r, z: o, t: i } = this, { x: a, y: n, z: c, t: p } = t, u = d((r - e) * (n + a)), h = d((r + e) * (n - a)), l = d(h - u);
    if (l === E)
      return this.double();
    const f = d(o * C * p), m = d(i * C * c), y = m + f, S = h + u, P = m - f, B = d(y * l), v = d(S * P), O = d(y * P), k = d(l * S);
    return new w(B, v, k, O);
  }
  subtract(t) {
    return this.add(t.negate());
  }
  precomputeWindow(t) {
    const e = 1 + 256 / t, r = [];
    let o = this, i = o;
    for (let a = 0; a < e; a++) {
      i = o, r.push(i);
      for (let n = 1; n < 2 ** (t - 1); n++)
        i = i.add(o), r.push(i);
      o = i.double();
    }
    return r;
  }
  wNAF(t, e) {
    !e && this.equals(w.BASE) && (e = x.BASE);
    const r = e && e._WINDOW_SIZE || 1;
    if (256 % r)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let o = e && kt.get(e);
    o || (o = this.precomputeWindow(r), e && r !== 1 && (o = w.normalizeZ(o), kt.set(e, o)));
    let i = w.ZERO, a = w.ZERO;
    const n = 1 + 256 / r, c = 2 ** (r - 1), p = BigInt(2 ** r - 1), u = 2 ** r, h = BigInt(r);
    for (let l = 0; l < n; l++) {
      const f = l * c;
      let m = Number(t & p);
      if (t >>= h, m > c && (m -= u, t += g), m === 0) {
        let y = o[f];
        l % 2 && (y = y.negate()), a = a.add(y);
      } else {
        let y = o[f + Math.abs(m) - 1];
        m < 0 && (y = y.negate()), i = i.add(y);
      }
    }
    return w.normalizeZ([i, a])[0];
  }
  multiply(t, e) {
    return this.wNAF(yt(t, R.l), e);
  }
  multiplyUnsafe(t) {
    let e = yt(t, R.l, !1);
    const r = w.BASE, o = w.ZERO;
    if (e === E)
      return o;
    if (this.equals(o) || e === g)
      return this;
    if (this.equals(r))
      return this.wNAF(e);
    let i = o, a = this;
    for (; e > E; )
      e & g && (i = i.add(a)), a = a.double(), e >>= g;
    return i;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(R.h).equals(w.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(R.l).equals(w.ZERO);
  }
  toAffine(t = vt(this.z)) {
    const { x: e, y: r, z: o } = this, i = d(e * t), a = d(r * t);
    if (d(o * t) !== g)
      throw new Error("invZ was invalid");
    return new x(i, a);
  }
  fromRistrettoBytes() {
    jt();
  }
  toRistrettoBytes() {
    jt();
  }
  fromRistrettoHash() {
    jt();
  }
}
w.BASE = new w(R.Gx, R.Gy, g, d(R.Gx * R.Gy));
w.ZERO = new w(E, g, g, E);
function Gt(s) {
  if (!(s instanceof w))
    throw new TypeError("ExtendedPoint expected");
}
function Ct(s) {
  if (!(s instanceof _))
    throw new TypeError("RistrettoPoint expected");
}
function jt() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
class _ {
  constructor(t) {
    this.ep = t;
  }
  static calcElligatorRistrettoMap(t) {
    const { d: e } = R, r = d(rt * t * t), o = d((r + g) * Fe);
    let i = BigInt(-1);
    const a = d((i - e * r) * d(r + e));
    let { isValid: n, value: c } = Mt(o, a), p = d(c * t);
    V(p) || (p = d(-p)), n || (c = p), n || (i = r);
    const u = d(i * (r - g) * Te - a), h = c * c, l = d((c + c) * a), f = d(u * Oe), m = d(g - h), y = d(g + h);
    return new w(d(l * y), d(m * f), d(f * y), d(l * m));
  }
  static hashToCurve(t) {
    t = G(t, 64);
    const e = Pt(t.slice(0, 32)), r = this.calcElligatorRistrettoMap(e), o = Pt(t.slice(32, 64)), i = this.calcElligatorRistrettoMap(o);
    return new _(r.add(i));
  }
  static fromHex(t) {
    t = G(t, 32);
    const { a: e, d: r } = R, o = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", i = Pt(t);
    if (!Le(at(i), t) || V(i))
      throw new Error(o);
    const a = d(i * i), n = d(g + e * a), c = d(g - e * a), p = d(n * n), u = d(c * c), h = d(e * r * p - u), { isValid: l, value: f } = Jt(d(h * u)), m = d(f * c), y = d(f * m * h);
    let S = d((i + i) * m);
    V(S) && (S = d(-S));
    const P = d(n * y), B = d(S * P);
    if (!l || V(B) || P === E)
      throw new Error(o);
    return new _(new w(S, P, g, B));
  }
  toRawBytes() {
    let { x: t, y: e, z: r, t: o } = this.ep;
    const i = d(d(r + e) * d(r - e)), a = d(t * e), { value: n } = Jt(d(i * a ** C)), c = d(n * i), p = d(n * a), u = d(c * p * o);
    let h;
    if (V(o * u)) {
      let f = d(e * rt), m = d(t * rt);
      t = f, e = m, h = d(c * ke);
    } else
      h = p;
    V(t * u) && (e = d(-e));
    let l = d((r - e) * h);
    return V(l) && (l = d(-l)), at(l);
  }
  toHex() {
    return nt(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(t) {
    Ct(t);
    const e = this.ep, r = t.ep, o = d(e.x * r.y) === d(e.y * r.x), i = d(e.y * r.y) === d(e.x * r.x);
    return o || i;
  }
  add(t) {
    return Ct(t), new _(this.ep.add(t.ep));
  }
  subtract(t) {
    return Ct(t), new _(this.ep.subtract(t.ep));
  }
  multiply(t) {
    return new _(this.ep.multiply(t));
  }
  multiplyUnsafe(t) {
    return new _(this.ep.multiplyUnsafe(t));
  }
}
_.BASE = new _(w.BASE);
_.ZERO = new _(w.ZERO);
const kt = /* @__PURE__ */ new WeakMap();
class x {
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  _setWindowSize(t) {
    this._WINDOW_SIZE = t, kt.delete(this);
  }
  static fromHex(t, e = !0) {
    const { d: r, P: o } = R;
    t = G(t, 32);
    const i = t.slice();
    i[31] = t[31] & -129;
    const a = X(i);
    if (e && a >= o)
      throw new Error("Expected 0 < hex < P");
    if (!e && a >= oe)
      throw new Error("Expected 0 < hex < 2**256");
    const n = d(a * a), c = d(n - g), p = d(r * n + g);
    let { isValid: u, value: h } = Mt(c, p);
    if (!u)
      throw new Error("Point.fromHex: invalid y coordinate");
    const l = (h & g) === g;
    return (t[31] & 128) !== 0 !== l && (h = d(-h)), new x(h, a);
  }
  static async fromPrivateKey(t) {
    return (await St(t)).point;
  }
  toRawBytes() {
    const t = at(this.y);
    return t[31] |= this.x & g ? 128 : 0, t;
  }
  toHex() {
    return nt(this.toRawBytes());
  }
  toX25519() {
    const { y: t } = this, e = d((g + t) * vt(g - t));
    return at(e);
  }
  isTorsionFree() {
    return w.fromAffine(this).isTorsionFree();
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  negate() {
    return new x(d(-this.x), this.y);
  }
  add(t) {
    return w.fromAffine(this).add(w.fromAffine(t)).toAffine();
  }
  subtract(t) {
    return this.add(t.negate());
  }
  multiply(t) {
    return w.fromAffine(this).multiply(t, this).toAffine();
  }
}
x.BASE = new x(R.Gx, R.Gy);
x.ZERO = new x(E, g);
class It {
  constructor(t, e) {
    this.r = t, this.s = e, this.assertValidity();
  }
  static fromHex(t) {
    const e = G(t, 64), r = x.fromHex(e.slice(0, 32), !1), o = X(e.slice(32, 64));
    return new It(r, o);
  }
  assertValidity() {
    const { r: t, s: e } = this;
    if (!(t instanceof x))
      throw new Error("Expected Point instance");
    return yt(e, R.l, !1), this;
  }
  toRawBytes() {
    const t = new Uint8Array(64);
    return t.set(this.r.toRawBytes()), t.set(at(this.s), 32), t;
  }
  toHex() {
    return nt(this.toRawBytes());
  }
}
function Ie(...s) {
  if (!s.every((r) => r instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (s.length === 1)
    return s[0];
  const t = s.reduce((r, o) => r + o.length, 0), e = new Uint8Array(t);
  for (let r = 0, o = 0; r < s.length; r++) {
    const i = s[r];
    e.set(i, o), o += i.length;
  }
  return e;
}
const Me = Array.from({ length: 256 }, (s, t) => t.toString(16).padStart(2, "0"));
function nt(s) {
  if (!(s instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < s.length; e++)
    t += Me[s[e]];
  return t;
}
function ie(s) {
  if (typeof s != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof s);
  if (s.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(s.length / 2);
  for (let e = 0; e < t.length; e++) {
    const r = e * 2, o = s.slice(r, r + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    t[e] = i;
  }
  return t;
}
function ae(s) {
  const e = s.toString(16).padStart(64, "0");
  return ie(e);
}
function at(s) {
  return ae(s).reverse();
}
function V(s) {
  return (d(s) & g) === g;
}
function X(s) {
  if (!(s instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + nt(Uint8Array.from(s).reverse()));
}
function Pt(s) {
  return d(X(s) & C ** re - g);
}
function d(s, t = R.P) {
  const e = s % t;
  return e >= E ? e : t + e;
}
function vt(s, t = R.P) {
  if (s === E || t <= E)
    throw new Error(`invert: expected positive integers, got n=${s} mod=${t}`);
  let e = d(s, t), r = t, o = E, i = g;
  for (; e !== E; ) {
    const n = r / e, c = r % e, p = o - i * n;
    r = e, e = c, o = i, i = p;
  }
  if (r !== g)
    throw new Error("invert: does not exist");
  return d(o, t);
}
function $e(s, t = R.P) {
  const e = new Array(s.length), r = s.reduce((i, a, n) => a === E ? i : (e[n] = i, d(i * a, t)), g), o = vt(r, t);
  return s.reduceRight((i, a, n) => a === E ? i : (e[n] = d(i * e[n], t), d(i * a, t)), o), e;
}
function F(s, t) {
  const { P: e } = R;
  let r = s;
  for (; t-- > E; )
    r *= r, r %= e;
  return r;
}
function De(s) {
  const { P: t } = R, e = BigInt(5), r = BigInt(10), o = BigInt(20), i = BigInt(40), a = BigInt(80), c = s * s % t * s % t, p = F(c, C) * c % t, u = F(p, g) * s % t, h = F(u, e) * u % t, l = F(h, r) * h % t, f = F(l, o) * l % t, m = F(f, i) * f % t, y = F(m, a) * m % t, S = F(y, a) * m % t, P = F(S, r) * h % t;
  return { pow_p_5_8: F(P, C) * s % t, b2: c };
}
function Mt(s, t) {
  const e = d(t * t * t), r = d(e * e * t), o = De(s * r).pow_p_5_8;
  let i = d(s * e * o);
  const a = d(t * i * i), n = i, c = d(i * rt), p = a === s, u = a === d(-s), h = a === d(-s * rt);
  return p && (i = n), (u || h) && (i = c), V(i) && (i = d(-i)), { isValid: p || u, value: i };
}
function Jt(s) {
  return Mt(g, s);
}
async function qt(...s) {
  const t = await ct.sha512(Ie(...s)), e = X(t);
  return d(e, R.l);
}
function Le(s, t) {
  if (s.length !== t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e])
      return !1;
  return !0;
}
function G(s, t) {
  const e = s instanceof Uint8Array ? Uint8Array.from(s) : ie(s);
  if (typeof t == "number" && e.length !== t)
    throw new Error(`Expected ${t} bytes`);
  return e;
}
function yt(s, t, e = !0) {
  if (!t)
    throw new TypeError("Specify max value");
  if (typeof s == "number" && Number.isSafeInteger(s) && (s = BigInt(s)), typeof s == "bigint" && s < t) {
    if (e) {
      if (E < s)
        return s;
    } else if (E <= s)
      return s;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function We(s) {
  return s[0] &= 248, s[31] &= 127, s[31] |= 64, s;
}
async function St(s) {
  if (s = typeof s == "bigint" || typeof s == "number" ? ae(yt(s, oe)) : G(s), s.length !== 32)
    throw new Error("Expected 32 bytes");
  const t = await ct.sha512(s), e = We(t.slice(0, 32)), r = t.slice(32, 64), o = d(X(e), R.l), i = x.BASE.multiply(o), a = i.toRawBytes();
  return { head: e, prefix: r, scalar: o, point: i, pointBytes: a };
}
async function ne(s) {
  return (await St(s)).pointBytes;
}
async function ze(s, t) {
  s = G(s);
  const { prefix: e, scalar: r, pointBytes: o } = await St(t), i = await qt(e, s), a = x.BASE.multiply(i), n = await qt(a.toRawBytes(), o, s), c = d(i + n * r, R.l);
  return new It(a, c).toRawBytes();
}
x.BASE._setWindowSize(8);
const W = {
  node: Be,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
}, ct = {
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  bytesToHex: nt,
  getExtendedPublicKey: St,
  mod: d,
  invert: vt,
  hashToPrivateScalar: (s) => {
    if (s = G(s), s.length < 40 || s.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const t = d(X(s), R.l);
    if (t === E || t === g)
      throw new Error("Invalid private key");
    return t;
  },
  randomBytes: (s = 32) => {
    if (W.web)
      return W.web.getRandomValues(new Uint8Array(s));
    if (W.node) {
      const { randomBytes: t } = W.node;
      return new Uint8Array(t(s).buffer);
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => ct.randomBytes(32),
  sha512: async (s) => {
    if (W.web) {
      const t = await W.web.subtle.digest("SHA-512", s.buffer);
      return new Uint8Array(t);
    } else {
      if (W.node)
        return Uint8Array.from(W.node.createHash("sha512").update(s).digest());
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(s = 8, t = x.BASE) {
    const e = t.equals(x.BASE) ? t : new x(t.x, t.y);
    return e._setWindowSize(s), e.multiply(C), e;
  }
};
function He(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var Ve = function(s, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  var e = typeof t.cycles == "boolean" ? t.cycles : !1, r = t.cmp && /* @__PURE__ */ function(i) {
    return function(a) {
      return function(n, c) {
        var p = { key: n, value: a[n] }, u = { key: c, value: a[c] };
        return i(p, u);
      };
    };
  }(t.cmp), o = [];
  return function i(a) {
    if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a !== void 0) {
      if (typeof a == "number") return isFinite(a) ? "" + a : "null";
      if (typeof a != "object") return JSON.stringify(a);
      var n, c;
      if (Array.isArray(a)) {
        for (c = "[", n = 0; n < a.length; n++)
          n && (c += ","), c += i(a[n]) || "null";
        return c + "]";
      }
      if (a === null) return "null";
      if (o.indexOf(a) !== -1) {
        if (e) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var p = o.push(a) - 1, u = Object.keys(a).sort(r && r(a));
      for (c = "", n = 0; n < u.length; n++) {
        var h = u[n], l = i(a[h]);
        l && (c && (c += ","), c += JSON.stringify(h) + ":" + l);
      }
      return o.splice(p, 1), "{" + c + "}";
    }
  }(s);
};
const Ke = /* @__PURE__ */ He(Ve);
var Y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", tt = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var ht = 0; ht < Y.length; ht++)
  tt[Y.charCodeAt(ht)] = ht;
var bt = function(s) {
  var t = new Uint8Array(s), e, r = t.length, o = "";
  for (e = 0; e < r; e += 3)
    o += Y[t[e] >> 2], o += Y[(t[e] & 3) << 4 | t[e + 1] >> 4], o += Y[(t[e + 1] & 15) << 2 | t[e + 2] >> 6], o += Y[t[e + 2] & 63];
  return r % 3 === 2 ? o = o.substring(0, o.length - 1) + "=" : r % 3 === 1 && (o = o.substring(0, o.length - 2) + "=="), o;
}, ce = function(s) {
  var t = s.length * 0.75, e = s.length, r, o = 0, i, a, n, c;
  s[s.length - 1] === "=" && (t--, s[s.length - 2] === "=" && t--);
  var p = new ArrayBuffer(t), u = new Uint8Array(p);
  for (r = 0; r < e; r += 4)
    i = tt[s.charCodeAt(r)], a = tt[s.charCodeAt(r + 1)], n = tt[s.charCodeAt(r + 2)], c = tt[s.charCodeAt(r + 3)], u[o++] = i << 2 | a >> 4, u[o++] = (a & 15) << 4 | n >> 2, u[o++] = (n & 3) << 6 | c & 63;
  return p;
};
/*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) */
const Ut = (s) => new DataView(s.buffer, s.byteOffset, s.byteLength), Ge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ge)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (s, t) => t.toString(16).padStart(2, "0"));
(() => {
  const s = typeof module < "u" && typeof module.require == "function" && module.require.bind(module);
  try {
    if (s) {
      const { setImmediate: t } = s("timers");
      return () => new Promise((e) => t(e));
    }
  } catch {
  }
  return () => new Promise((t) => setTimeout(t, 0));
})();
function Je(s) {
  if (typeof s != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof s}`);
  return new TextEncoder().encode(s);
}
function de(s) {
  if (typeof s == "string" && (s = Je(s)), !(s instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof s})`);
  return s;
}
class qe {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function $t(s) {
  const t = (r) => s().update(de(r)).digest(), e = s();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => s(), t.init = t.create, t;
}
function Ze(s, t, e, r) {
  if (typeof s.setBigUint64 == "function")
    return s.setBigUint64(t, e, r);
  const o = BigInt(32), i = BigInt(4294967295), a = Number(e >> o & i), n = Number(e & i), c = r ? 4 : 0, p = r ? 0 : 4;
  s.setUint32(t + c, a, r), s.setUint32(t + p, n, r);
}
class Ye extends qe {
  constructor(t, e, r, o) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = o, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Ut(this.buffer);
  }
  update(t) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    const { view: e, buffer: r, blockLen: o, finished: i } = this;
    if (i)
      throw new Error("digest() was already called");
    t = de(t);
    const a = t.length;
    for (let n = 0; n < a; ) {
      const c = Math.min(o - this.pos, a - n);
      if (c === o) {
        const p = Ut(t);
        for (; o <= a - n; n += o)
          this.process(p, n);
        continue;
      }
      r.set(t.subarray(n, n + c), this.pos), this.pos += c, n += c, this.pos === o && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    if (!(t instanceof Uint8Array) || t.length < this.outputLen)
      throw new Error("_Sha2: Invalid output buffer");
    if (this.finished)
      throw new Error("digest() was already called");
    this.finished = !0;
    const { buffer: e, view: r, blockLen: o, isLE: i } = this;
    let { pos: a } = this;
    e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o - a && (this.process(r, 0), a = 0);
    for (let c = a; c < o; c++)
      e[c] = 0;
    Ze(r, o - 8, BigInt(this.length * 8), i), this.process(r, 0);
    const n = Ut(t);
    this.get().forEach((c, p) => n.setUint32(4 * p, c, i));
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const r = t.slice(0, e);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: r, length: o, finished: i, destroyed: a, pos: n } = this;
    return t.length = o, t.pos = n, t.finished = i, t.destroyed = a, o % e && t.buffer.set(r), t;
  }
}
const ut = BigInt(2 ** 32 - 1), Zt = BigInt(32);
function Xe(s, t = !1) {
  return t ? { h: Number(s & ut), l: Number(s >> Zt & ut) } : { h: Number(s >> Zt & ut) | 0, l: Number(s & ut) | 0 };
}
function Qe(s, t = !1) {
  let e = new Uint32Array(s.length), r = new Uint32Array(s.length);
  for (let o = 0; o < s.length; o++) {
    const { h: i, l: a } = Xe(s[o], t);
    [e[o], r[o]] = [i, a];
  }
  return [e, r];
}
const Yt = (s, t, e) => s >>> e, Xt = (s, t, e) => s << 32 - e | t >>> e, q = (s, t, e) => s >>> e | t << 32 - e, Z = (s, t, e) => s << 32 - e | t >>> e, lt = (s, t, e) => s << 64 - e | t >>> e - 32, mt = (s, t, e) => s >>> e - 32 | t << 64 - e;
function $(s, t, e, r) {
  const o = (t >>> 0) + (r >>> 0);
  return { h: s + e + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
const ts = (s, t, e) => (s >>> 0) + (t >>> 0) + (e >>> 0), es = (s, t, e, r) => t + e + r + (s / 2 ** 32 | 0) | 0, ss = (s, t, e, r) => (s >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0), rs = (s, t, e, r, o) => t + e + r + o + (s / 2 ** 32 | 0) | 0, os = (s, t, e, r, o) => (s >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0) + (o >>> 0), is = (s, t, e, r, o, i) => t + e + r + o + i + (s / 2 ** 32 | 0) | 0, [as, ns] = Qe([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((s) => BigInt(s))), z = new Uint32Array(80), H = new Uint32Array(80);
class Dt extends Ye {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: e, Bh: r, Bl: o, Ch: i, Cl: a, Dh: n, Dl: c, Eh: p, El: u, Fh: h, Fl: l, Gh: f, Gl: m, Hh: y, Hl: S } = this;
    return [t, e, r, o, i, a, n, c, p, u, h, l, f, m, y, S];
  }
  // prettier-ignore
  set(t, e, r, o, i, a, n, c, p, u, h, l, f, m, y, S) {
    this.Ah = t | 0, this.Al = e | 0, this.Bh = r | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = a | 0, this.Dh = n | 0, this.Dl = c | 0, this.Eh = p | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = l | 0, this.Gh = f | 0, this.Gl = m | 0, this.Hh = y | 0, this.Hl = S | 0;
  }
  process(t, e) {
    for (let v = 0; v < 16; v++, e += 4)
      z[v] = t.getUint32(e), H[v] = t.getUint32(e += 4);
    for (let v = 16; v < 80; v++) {
      const O = z[v - 15] | 0, k = H[v - 15] | 0, Rt = q(O, k, 1) ^ q(O, k, 8) ^ Yt(O, k, 7), At = Z(O, k, 1) ^ Z(O, k, 8) ^ Xt(O, k, 7), I = z[v - 2] | 0, M = H[v - 2] | 0, dt = q(I, M, 19) ^ lt(I, M, 61) ^ Yt(I, M, 6), xt = Z(I, M, 19) ^ mt(I, M, 61) ^ Xt(I, M, 6), pt = ss(At, xt, H[v - 7], H[v - 16]), Et = rs(pt, Rt, dt, z[v - 7], z[v - 16]);
      z[v] = Et | 0, H[v] = pt | 0;
    }
    let { Ah: r, Al: o, Bh: i, Bl: a, Ch: n, Cl: c, Dh: p, Dl: u, Eh: h, El: l, Fh: f, Fl: m, Gh: y, Gl: S, Hh: P, Hl: B } = this;
    for (let v = 0; v < 80; v++) {
      const O = q(h, l, 14) ^ q(h, l, 18) ^ lt(h, l, 41), k = Z(h, l, 14) ^ Z(h, l, 18) ^ mt(h, l, 41), Rt = h & f ^ ~h & y, At = l & m ^ ~l & S, I = os(B, k, At, ns[v], H[v]), M = is(I, P, O, Rt, as[v], z[v]), dt = I | 0, xt = q(r, o, 28) ^ lt(r, o, 34) ^ lt(r, o, 39), pt = Z(r, o, 28) ^ mt(r, o, 34) ^ mt(r, o, 39), Et = r & i ^ r & n ^ i & n, je = o & a ^ o & c ^ a & c;
      P = y | 0, B = S | 0, y = f | 0, S = m | 0, f = h | 0, m = l | 0, { h, l } = $(p | 0, u | 0, M | 0, dt | 0), p = n | 0, u = c | 0, n = i | 0, c = a | 0, i = r | 0, a = o | 0;
      const Vt = ts(dt, pt, je);
      r = es(Vt, M, xt, Et), o = Vt | 0;
    }
    ({ h: r, l: o } = $(this.Ah | 0, this.Al | 0, r | 0, o | 0)), { h: i, l: a } = $(this.Bh | 0, this.Bl | 0, i | 0, a | 0), { h: n, l: c } = $(this.Ch | 0, this.Cl | 0, n | 0, c | 0), { h: p, l: u } = $(this.Dh | 0, this.Dl | 0, p | 0, u | 0), { h, l } = $(this.Eh | 0, this.El | 0, h | 0, l | 0), { h: f, l: m } = $(this.Fh | 0, this.Fl | 0, f | 0, m | 0), { h: y, l: S } = $(this.Gh | 0, this.Gl | 0, y | 0, S | 0), { h: P, l: B } = $(this.Hh | 0, this.Hl | 0, P | 0, B | 0), this.set(r, o, i, a, n, c, p, u, h, l, f, m, y, S, P, B);
  }
  roundClean() {
    z.fill(0), H.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class cs extends Dt {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class ds extends Dt {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
const ps = $t(() => new Dt());
$t(() => new cs());
$t(() => new ds());
var pe = /* @__PURE__ */ ((s) => (s.ATOMIC_URL = "https://atomicdata.dev/datatypes/atomicURL", s.BOOLEAN = "https://atomicdata.dev/datatypes/boolean", s.DATE = "https://atomicdata.dev/datatypes/date", s.FLOAT = "https://atomicdata.dev/datatypes/float", s.INTEGER = "https://atomicdata.dev/datatypes/integer", s.MARKDOWN = "https://atomicdata.dev/datatypes/markdown", s.RESOURCEARRAY = "https://atomicdata.dev/datatypes/resourceArray", s.SLUG = "https://atomicdata.dev/datatypes/slug", s.STRING = "https://atomicdata.dev/datatypes/string", s.TIMESTAMP = "https://atomicdata.dev/datatypes/timestamp", s.UNKNOWN = "unknown-datatype", s))(pe || {});
const hs = new Set(Object.values(pe)), us = (s) => hs.has(s) ? s : "unknown-datatype", ls = /^[a-z0-9]+(?:-[a-z0-9]+)*$/, ms = /^\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/, fs = (s, t) => {
  let e = null;
  if (s === void 0)
    throw new Error(`Value is undefined, expected ${t}`);
  switch (t) {
    case "https://atomicdata.dev/datatypes/string": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      break;
    }
    case "https://atomicdata.dev/datatypes/markdown": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      break;
    }
    case "https://atomicdata.dev/datatypes/slug": {
      if (!Q(s)) {
        e = "Not a slug, not even a string";
        break;
      }
      s.match(ls) === null && (e = "Not a valid slug. Only lowercase letters and numbers with dashes `-` between them");
      break;
    }
    case "https://atomicdata.dev/datatypes/atomicURL": {
      if (!Q(s)) {
        e = "Not a string. Should be a URL";
        break;
      }
      N.tryValidSubject(s);
      break;
    }
    case "https://atomicdata.dev/datatypes/resourceArray": {
      if (!Lt(s)) {
        e = "Not an array";
        break;
      }
      s.map((r, o) => {
        try {
          N.tryValidSubject(r);
        } catch {
          const a = new Error("Invalid URL");
          throw a.index = o, a;
        }
      });
      break;
    }
    case "https://atomicdata.dev/datatypes/integer": {
      if (!he(s)) {
        e = "Not a number";
        break;
      }
      s % 1 !== 0 && (e = "Not an integer");
      break;
    }
    case "https://atomicdata.dev/datatypes/date": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      s.match(ms) === null && (e = "Not a date string: YYYY-MM-DD");
      break;
    }
  }
  if (e !== null)
    throw new Error(e);
};
function Lt(s) {
  return Object.prototype.toString.call(s) === "[object Array]";
}
function Q(s) {
  return typeof s == "string";
}
function he(s) {
  return typeof s == "number";
}
const nr = {
  "https://atomicdata.dev/datatypes/string": "String",
  "https://atomicdata.dev/datatypes/slug": "Slug",
  "https://atomicdata.dev/datatypes/markdown": "Markdown",
  "https://atomicdata.dev/datatypes/integer": "Integer",
  "https://atomicdata.dev/datatypes/float": "Float",
  "https://atomicdata.dev/datatypes/boolean": "Boolean",
  "https://atomicdata.dev/datatypes/date": "Date",
  "https://atomicdata.dev/datatypes/timestamp": "Timestamp",
  "https://atomicdata.dev/datatypes/atomicURL": "Resource",
  "https://atomicdata.dev/datatypes/resourceArray": "ResourceArray",
  "unknown-datatype": "Unknown"
};
var et = /* @__PURE__ */ ((s) => (s.Unauthorized = "Unauthorized", s.NotFound = "NotFound", s.Server = "Server", s.Client = "Client", s))(et || {});
function gs(s) {
  if (s instanceof j) {
    if (s.type === "Unauthorized")
      return !0;
    if (s.message.includes("Unauthorized"))
      return !0;
  }
  return !1;
}
function cr(s) {
  return s instanceof j;
}
class j extends Error {
  /** Creates an AtomicError. The message can be either a plain string, or a JSON-AD Error Resource */
  constructor(t, e = "Client") {
    super(t), Object.setPrototypeOf(this, j.prototype), this.type = e, this.message = t;
    try {
      const o = JSON.parse(t)[A.properties.description];
      o && (this.message = o);
    } catch {
    }
    this.message || (this.message = this.createMessage());
  }
  static fromResource(t) {
    return new j(t.get(A.properties.description).toString());
  }
  createMessage() {
    switch (this.type) {
      case "Unauthorized":
        return "You don't have the rights to do this.";
      case "NotFound":
        return "404 Not found.";
      case "Server":
        return "500 Unknown server error.";
      default:
        return "Unknown error.";
    }
  }
}
class ue {
  constructor() {
    this.subscriptions = /* @__PURE__ */ new Map();
  }
  register(t, e) {
    const r = this.subscriptions.get(t) ?? /* @__PURE__ */ new Set();
    return r.add(e), this.subscriptions.set(t, r), () => {
      r.delete(e);
    };
  }
  async emit(t, ...e) {
    if (!this.subscriptions.has(t)) return;
    const r = this.subscriptions.get(t), o = async (i) => i(...e);
    r && await Promise.allSettled([...r].map((i) => o(i)));
  }
  hasSubscriptions(t) {
    return this.subscriptions.has(t);
  }
}
class Wt {
  constructor(t, e, r, o = !1) {
    this.__internalObject = this, this.pages = /* @__PURE__ */ new Map(), this._totalMembers = 0, this.store = t, this.server = e, this.params = r, o || (this._waitForReady = this.fetchPage(0)), this.clearPages = this.clearPages.bind(this);
  }
  get property() {
    return this.params.property;
  }
  get value() {
    return this.params.value;
  }
  get sortBy() {
    return this.params.sort_by;
  }
  get sortDesc() {
    return !!this.params.sort_desc;
  }
  get pageSize() {
    return parseInt(this.params.page_size, 10);
  }
  get totalMembers() {
    return this._totalMembers;
  }
  get totalPages() {
    return Math.ceil(this.totalMembers / this.pageSize);
  }
  waitForReady() {
    return this._waitForReady;
  }
  async getMemberWithIndex(t) {
    if (t >= this.totalMembers)
      throw new Error("Index out of bounds");
    const e = Math.floor(t / this.pageSize);
    return this.pages.has(e) || (this._waitForReady = this.fetchPage(e), await this._waitForReady), this.pages.get(e).getSubjects(Tt.properties.members)[t % this.pageSize];
  }
  clearPages() {
    this.pages = /* @__PURE__ */ new Map();
  }
  async refresh() {
    return this.clearPages(), this._waitForReady = this.fetchPage(0), this._waitForReady;
  }
  clone() {
    const t = new Wt(this.store, this.server, this.params);
    return t._totalMembers = this._totalMembers, t._waitForReady = this._waitForReady, t.pages = this.pages, t;
  }
  async *[Symbol.asyncIterator]() {
    await this.waitForReady();
    for (let t = 0; t < this.totalMembers; t++) {
      const e = await this.getMemberWithIndex(t);
      e !== void 0 && (yield e);
    }
  }
  async getAllMembers() {
    const t = [];
    for await (const e of this)
      t.push(e);
    return t;
  }
  async getMembersOnPage(t) {
    return this.pages.has(t) || await this.fetchPage(t), (this.pages.get(t).props.members ?? []).filter((r) => r !== void 0);
  }
  buildSubject(t) {
    const e = new URL(`${this.server}/query`);
    for (const [r, o] of Object.entries(this.params))
      e.searchParams.set(r, o);
    return e.searchParams.set("current_page", `${t}`), e.toString();
  }
  async fetchPage(t) {
    const e = this.buildSubject(t), r = await this.store.fetchResourceFromServer(e);
    if (!r)
      throw new Error("Invalid collection: resource does not exist");
    if (r.error)
      throw new Error(
        `Invalid collection: resource has error: ${r.error}`
      );
    this.pages.set(t, r);
    const o = r.props.totalMembers;
    if (!he(o))
      throw new Error("Invalid collection: total-members is not a number");
    this._totalMembers = o;
  }
}
function dr(s) {
  return s.__internalObject !== s && console.warn("Attempted to proxy a proxy for a collection"), new Proxy(s.__internalObject, {});
}
class ys {
  constructor(t, e) {
    this.params = {
      page_size: "30"
    }, this.store = t, this.server = e ?? new URL(t.getServerUrl()).origin;
  }
  setProperty(t) {
    return this.params.property = t, this;
  }
  setValue(t) {
    return this.params.value = t, this;
  }
  setSortBy(t) {
    return this.params.sort_by = t, this;
  }
  setSortDesc(t) {
    return this.params.sort_desc = t, this;
  }
  setPageSize(t) {
    return this.params.page_size = `${t}`, this;
  }
  build() {
    return new Wt(this.store, this.server, this.params);
  }
  async buildAndFetch() {
    const t = this.build();
    return await t.waitForReady(), t;
  }
}
const bs = {
  agent: "https://atomicdata.dev/classes/Agent",
  chatRoom: "https://atomicdata.dev/classes/ChatRoom",
  collection: "https://atomicdata.dev/classes/Collection",
  commit: "https://atomicdata.dev/classes/Commit",
  class: "https://atomicdata.dev/classes/Class",
  document: "https://atomicdata.dev/classes/Document",
  bookmark: "https://atomicdata.dev/class/Bookmark",
  elements: {
    paragraph: "https://atomicdata.dev/classes/elements/Paragraph"
  },
  error: "https://atomicdata.dev/classes/Error",
  property: "https://atomicdata.dev/classes/Property",
  datatype: "https://atomicdata.dev/classes/Datatype",
  endpoint: "https://atomicdata.dev/classes/Endpoint",
  drive: "https://atomicdata.dev/classes/Drive",
  redirect: "https://atomicdata.dev/classes/Redirect",
  invite: "https://atomicdata.dev/classes/Invite",
  file: "https://atomicdata.dev/classes/File",
  message: "https://atomicdata.dev/classes/Message",
  importer: "https://atomicdata.dev/classes/Importer",
  folder: "https://atomicdata.dev/classes/Folder",
  article: "https://atomicdata.dev/classes/Article",
  displayStyle: "https://atomicdata.dev/class/DisplayStyle",
  displayStyles: {
    grid: "https://atomicdata.dev/display-style/grid",
    list: "https://atomicdata.dev/display-style/list"
  },
  dateFormat: "https://atomicdata.dev/classes/DateFormat",
  numberFormat: "https://atomicdata.dev/classes/NumberFormat",
  constraintProperties: {
    rangeProperty: "https://atomicdata.dev/classes/RangeProperty",
    floatRangeProperty: "https://atomicdata.dev/classes/FloatRangeProperty",
    formattedNumber: "https://atomicdata.dev/classes/FormattedNumber",
    selectProperty: "https://atomicdata.dev/classes/SelectProperty",
    formattedDate: "https://atomicdata.dev/classes/FormattedDate"
  },
  table: "https://atomicdata.dev/classes/Table",
  tag: "https://atomicdata.dev/classes/Tag",
  ontology: "https://atomicdata.dev/class/ontology"
}, U = {
  /** Collection of all the AtomicData.dev properties */
  allowsOnly: "https://atomicdata.dev/properties/allowsOnly",
  getAll: "https://atomicdata.dev/properties/?page_size=999",
  children: "https://atomicdata.dev/properties/children",
  classType: "https://atomicdata.dev/properties/classtype",
  createdBy: "https://atomicdata.dev/properties/createdBy",
  datatype: "https://atomicdata.dev/properties/datatype",
  description: "https://atomicdata.dev/properties/description",
  drives: "https://atomicdata.dev/properties/drives",
  incomplete: "https://atomicdata.dev/properties/incomplete",
  isA: "https://atomicdata.dev/properties/isA",
  isDynamic: "https://atomicdata.dev/properties/isDynamic",
  name: "https://atomicdata.dev/properties/name",
  parent: "https://atomicdata.dev/properties/parent",
  paymentPointer: "https://atomicdata.dev/properties/paymentPointer",
  read: "https://atomicdata.dev/properties/read",
  recommends: "https://atomicdata.dev/properties/recommends",
  requires: "https://atomicdata.dev/properties/requires",
  shortname: "https://atomicdata.dev/properties/shortname",
  subResources: "https://atomicdata.dev/properties/subresources",
  write: "https://atomicdata.dev/properties/write",
  displayStyle: "https://atomicdata.dev/property/display-style",
  publishedAt: "https://atomicdata.dev/properties/published-at",
  agent: {
    publicKey: "https://atomicdata.dev/properties/publicKey"
  },
  collection: {
    members: "https://atomicdata.dev/properties/collection/members",
    currentPage: "https://atomicdata.dev/properties/collection/currentPage",
    pageSize: "https://atomicdata.dev/properties/collection/pageSize",
    property: "https://atomicdata.dev/properties/collection/property",
    totalMembers: "https://atomicdata.dev/properties/collection/totalMembers",
    totalPages: "https://atomicdata.dev/properties/collection/totalPages",
    value: "https://atomicdata.dev/properties/collection/value"
  },
  commit: {
    subject: "https://atomicdata.dev/properties/subject",
    createdAt: "https://atomicdata.dev/properties/createdAt",
    lastCommit: "https://atomicdata.dev/properties/lastCommit",
    previousCommit: "https://atomicdata.dev/properties/previousCommit",
    signer: "https://atomicdata.dev/properties/signer",
    set: "https://atomicdata.dev/properties/set",
    push: "https://atomicdata.dev/properties/push",
    remove: "https://atomicdata.dev/properties/remove",
    destroy: "https://atomicdata.dev/properties/destroy",
    signature: "https://atomicdata.dev/properties/signature"
  },
  document: {
    elements: "https://atomicdata.dev/properties/documents/elements"
  },
  endpoint: {
    parameters: "https://atomicdata.dev/properties/endpoint/parameters",
    results: "https://atomicdata.dev/properties/endpoint/results"
  },
  search: {
    query: "https://atomicdata.dev/properties/search/query",
    limit: "https://atomicdata.dev/properties/search/limit",
    property: "https://atomicdata.dev/properties/search/property"
  },
  redirect: {
    destination: "https://atomicdata.dev/properties/destination",
    redirectAgent: "https://atomicdata.dev/properties/invite/redirectAgent"
  },
  invite: {
    agent: "https://atomicdata.dev/properties/invite/agent",
    publicKey: "https://atomicdata.dev/properties/invite/publicKey",
    target: "https://atomicdata.dev/properties/invite/target",
    usagesLeft: "https://atomicdata.dev/properties/invite/usagesLeft",
    users: "https://atomicdata.dev/properties/invite/users",
    write: "https://atomicdata.dev/properties/invite/write"
  },
  file: {
    filename: "https://atomicdata.dev/properties/filename",
    filesize: "https://atomicdata.dev/properties/filesize",
    downloadUrl: "https://atomicdata.dev/properties/downloadURL",
    mimetype: "https://atomicdata.dev/properties/mimetype",
    attachments: "https://atomicdata.dev/properties/attachments"
  },
  chatRoom: {
    messages: "https://atomicdata.dev/properties/messages",
    nextPage: "https://atomicdata.dev/properties/nextPage",
    replyTo: "https://atomicdata.dev/properties/replyTo"
  },
  bookmark: {
    url: "https://atomicdata.dev/property/url",
    preview: "https://atomicdata.dev/property/preview",
    imageUrl: "https://atomicdata.dev/properties/imageUrl"
  },
  constraints: {
    max: "https://atomicdata.dev/properties/max",
    min: "https://atomicdata.dev/properties/min",
    maxFloat: "https://atomicdata.dev/properties/maxFloat",
    minFloat: "https://atomicdata.dev/properties/minFloat",
    numberFormatting: "https://atomicdata.dev/properties/numberFormatting",
    decimalPlaces: "https://atomicdata.dev/properties/decimalPlaces",
    dateFormat: "https://atomicdata.dev/properties/dateFormat"
  },
  table: {
    tableColumnWidths: "https://atomicdata.dev/properties/tableColumnWidths"
  },
  ontology: {
    customNodePositioning: "https://atomicdata.dev/properties/custom-node-positioning"
  },
  color: "https://atomicdata.dev/properties/color",
  emoji: "https://atomicdata.dev/properties/emoji",
  classes: "https://atomicdata.dev/properties/classes",
  properties: "https://atomicdata.dev/properties/properties",
  instances: "https://atomicdata.dev/properties/instances"
}, ws = {
  atomicUrl: "https://atomicdata.dev/datatypes/atomicURL",
  boolean: "https://atomicdata.dev/datatypes/boolean",
  date: "https://atomicdata.dev/datatypes/date",
  float: "https://atomicdata.dev/datatypes/float",
  integer: "https://atomicdata.dev/datatypes/integer",
  markdown: "https://atomicdata.dev/datatypes/markdown",
  resourceArray: "https://atomicdata.dev/datatypes/resourceArray",
  slug: "https://atomicdata.dev/datatypes/slug",
  string: "https://atomicdata.dev/datatypes/string",
  timestamp: "https://atomicdata.dev/datatypes/timestamp"
}, le = {
  publicAgent: "https://atomicdata.dev/agents/publicAgent",
  displayStyleGrid: "https://atomicdata.dev/agents/publicAgent",
  numberFormats: {
    number: "https://atomicdata.dev/classes/NumberFormat/number",
    percentage: "https://atomicdata.dev/classes/NumberFormat/Percentage",
    currency: "https://atomicdata.dev/ontology/data-browser/number-format/vAikhI3z"
  },
  dateFormats: {
    localNumeric: "https://atomicdata.dev/classes/DateFormat/localNumeric",
    localLong: "https://atomicdata.dev/classes/DateFormat/localLong",
    localRelative: "https://atomicdata.dev/classes/DateFormat/localRelative"
  }
}, me = {
  import: "/import"
}, b = {
  properties: U,
  endpoints: me,
  classes: bs,
  datatypes: ws,
  instances: le
};
function _t(s) {
  if (s === void 0)
    throw new Error(`Not an array: ${s}, is ${typeof s}`);
  if (s.constructor === Array)
    return s;
  throw new Error(`Not an array: ${s}, is a ${typeof s}`);
}
function pr(s) {
  if (typeof s != "boolean")
    throw new Error(`Not a boolean: ${s}, is a ${typeof s}`);
  return s;
}
function hr(s) {
  if (typeof s == "number") {
    const t = /* @__PURE__ */ new Date(0);
    return t.setUTCMilliseconds(s), t;
  }
  if (typeof s == "string")
    return new Date(s.toString());
  throw new Error(`Cannot be converted into Date: ${s}, is a ${typeof s}`);
}
function ur(s) {
  if (typeof s != "number")
    throw new Error(`Not a number: ${s}, is a ${typeof s}`);
  return s;
}
function lr(s) {
  return (s == null ? void 0 : s.toString()) ?? "undefined";
}
function mr(s) {
  if (typeof s == "string")
    return s;
  if (s instanceof Date)
    throw new Error(`Not a resource: ${s}, is a Date`);
  if ((s == null ? void 0 : s.constructor) === Array)
    throw new Error(`Not a resource: ${s}, is an Array`);
  if (typeof s == "object") {
    const t = new J(), [e] = t.parseObject(s, "nested-resource");
    return e;
  }
  throw typeof s != "object" ? new Error(`Not a resource: ${s}, is a ${typeof s}`) : new Error(`Not a resource: ${s}, is a ${typeof s}`);
}
const K = "unknown-subject";
var vs = /* @__PURE__ */ ((s) => (s.LocalChange = "local-change", s))(vs || {});
class L {
  constructor(t, e) {
    if (this.loading = !1, this.appliedCommitSignatures = /* @__PURE__ */ new Set(), this.__internalObject = this, this.propvals = /* @__PURE__ */ new Map(), this.hasQueue = !1, this.eventManager = new ue(), typeof t != "string")
      throw new Error(
        "Invalid subject given to resource, must be a string, found " + typeof t
      );
    this.new = !!e, this._subject = t, this.commitBuilder = new ot(t);
  }
  /** The subject URL of the resource */
  get subject() {
    return this._subject;
  }
  /** A human readable title for the resource, returns first of eighter: name, shortname, filename or subject */
  get title() {
    return this.get(A.properties.name) ?? this.get(A.properties.shortname) ?? this.get(wt.properties.filename) ?? this.subject;
  }
  /**
   * Dynamic prop accessor, only works for known properties registered via an ontology.
   * @example const description = resource.props.description
   */
  get props() {
    const t = {};
    for (const e of this.propvals.keys()) {
      const r = Ue(e);
      r && (t[r] = this.get(e));
    }
    return t;
  }
  get store() {
    if (!this._store)
      throw console.error(`Resource ${this.title} has no store`), new Error("Resource has no store");
    return this._store;
  }
  on(t, e) {
    return this.eventManager.register(t, e);
  }
  /** @internal */
  setStore(t) {
    this._store = t;
  }
  /** Checks if the content of two Resource instances is equal */
  equals(t) {
    return this === t.__internalObject ? !0 : !(this.subject !== t.subject || this.new !== t.new || this.error !== t.error || this.loading !== t.loading || JSON.stringify(Array.from(this.propvals.entries())) !== JSON.stringify(Array.from(t.propvals.entries())) || JSON.stringify(Array.from(this.commitBuilder.set.entries())) !== JSON.stringify(Array.from(t.commitBuilder.set.entries())));
  }
  /** Checks if the agent has write rights by traversing the graph. Recursive function. */
  async canWrite(t, e) {
    const r = this.get(U.write);
    if (!t)
      return [!1, "No agent given"];
    if (r && _t(r).includes(t))
      return [!0, void 0];
    if (r && _t(r).includes(le.publicAgent))
      return [!0, void 0];
    const o = this.get(U.parent);
    return o ? o === t ? [!0, void 0] : e === o ? (console.warn("Circular parent", e), [!0, `Circular parent in ${this.subject}`]) : await (await this.store.getResource(o)).canWrite(t, this.subject) : [!1, `No write right or parent in ${this.subject}`];
  }
  /**
   * Creates a clone of the Resource, which makes sure the reference is
   * different from the previous one. This can be useful when doing reference compares.
   */
  clone() {
    const t = new L(this.subject);
    return t.propvals = structuredClone(this.propvals), t.loading = this.loading, t.new = this.new, t.error = structuredClone(this.error), t.commitError = this.commitError, t.commitBuilder = this.commitBuilder.clone(), t.appliedCommitSignatures = this.appliedCommitSignatures, t;
  }
  /** Checks if the resource is both loaded and free from errors */
  isReady() {
    return !this.loading && this.error === void 0;
  }
  /** Get a Value by its property
   * @param propUrl The subject of the property
   * @example
   * import { core } from '@tomic/lib'
   * const description = resource.get(core.properties.description)
   * const publishedAt = resource.get('https://my-atomicserver.dev/properties/published-at')
   */
  get(t) {
    return this.propvals.get(t);
  }
  /**
   * Get a Value by its property, returns as Array with subjects instead of the
   * full resource or throws error. Returns empty array if there is no value
   */
  getSubjects(t) {
    return this.getArray(t).map((e) => typeof e == "string" ? e : e["@id"]);
  }
  /**
   * Get a Value by its property, returns as Array or throws error. Returns
   * empty array if there is no value
   */
  getArray(t) {
    const e = this.propvals.get(t) ?? [];
    return _t(e);
  }
  /** Returns a list of classes of this resource */
  getClasses() {
    return this.getSubjects(A.properties.isA);
  }
  /** Checks if the resource is all of the given classes */
  hasClasses(...t) {
    return t.every(
      (e) => this.getClasses().includes(e)
    );
  }
  matchClass(t, e) {
    for (const [r, o] of Object.entries(t))
      if (this.hasClasses(r))
        return o;
    return e;
  }
  /** Remove the given classes from the resource */
  removeClasses(...t) {
    this.set(
      A.properties.isA,
      this.getClasses().filter(
        (e) => !t.includes(e)
      ),
      !1
    );
  }
  /** Adds the given classes to the resource */
  addClasses(...t) {
    const e = /* @__PURE__ */ new Set([...this.getClasses(), ...t]);
    return this.set(
      A.properties.isA,
      Array.from(e)
    );
  }
  /** Returns true if the resource has changes in it's commit builder that are not yet saved to the server. */
  hasUnsavedChanges() {
    return this.commitBuilder.hasUnsavedChanges();
  }
  getCommitsCollectionSubject() {
    const t = new URL(this.subject);
    return t.pathname = "/commits", t.searchParams.append("property", b.properties.commit.subject), t.searchParams.append("value", this.subject), t.searchParams.append("sort_by", b.properties.commit.createdAt), t.searchParams.append("include_nested", "true"), t.searchParams.append("page_size", "9999"), t.toString();
  }
  /** Returns a Collection with all children of this resource
   * @param pageSize The amount of children per page (default: 100)
   */
  async getChildrenCollection(t = 100) {
    return await new ys(this.store).setPageSize(t).setProperty(A.properties.parent).setValue(this.subject).buildAndFetch();
  }
  /** builds all versions using the Commits */
  async getHistory(t) {
    const r = (await this.store.fetchResourceFromServer(
      this.getCommitsCollectionSubject()
    )).get(
      U.collection.members
    ), o = [];
    let i = new L(this.subject);
    for (let a = 0; a < r.length; a++) {
      const n = await this.store.getResource(r[a]), c = xs(n), p = be(
        i.clone(),
        c
      );
      o.push({
        commit: c,
        resource: p
      }), i = p, t && a % 30 === 0 && (t(Math.round(a / r.length * 100)), await Rs());
    }
    return o;
  }
  async setVersion(t) {
    const e = t.resource.getPropVals();
    for (const r of this.propvals.keys())
      e.has(r) || this.remove(r);
    for (const [r, o] of e.entries())
      await this.set(r, o);
    await this.save();
  }
  /**
   * @deprecated use resource.subject
   */
  getSubject() {
    return this.subject;
  }
  /** Returns the subject URL of the Resource */
  getSubjectNoParams() {
    const t = new URL(this.subject);
    return t.origin + t.pathname;
  }
  /** Returns the internal Map of Property-Values */
  getPropVals() {
    return this.propvals;
  }
  /**
   * Iterates over the parents of the resource, returns who has read / write
   * rights for this resource
   */
  async getRights() {
    const t = [];
    this.getSubjects(U.write).forEach((i) => {
      t.push({
        for: i,
        type: "write",
        setIn: this.subject
      });
    }), this.getSubjects(U.read).forEach((i) => {
      t.push({
        for: i,
        type: "read",
        setIn: this.subject
      });
    });
    const o = this.get(U.parent);
    if (o) {
      if (o === this.subject)
        return console.warn("Circular parent", o), t;
      const a = await (await this.store.getResource(o)).getRights();
      t.push(...a);
    }
    return t;
  }
  /** Returns true is the resource had an `Unauthorized` 401 response. */
  isUnauthorized() {
    return !!this.error && gs(this.error);
  }
  /** Removes the resource form both the server and locally */
  async destroy(t) {
    if (this.new) {
      this.store.removeResource(this.subject);
      return;
    }
    const e = new ot(this.subject);
    if (e.setDestroy(!0), t === void 0 && (t = this.store.getAgent()), (t == null ? void 0 : t.subject) === void 0)
      throw new Error(
        "No agent has been set or passed, you cannot delete this."
      );
    const r = await e.sign(t.privateKey, t.subject), o = new URL(this.subject).origin + "/commit";
    await this.store.postCommit(r, o), this.store.removeResource(this.subject);
  }
  /** @deprecated use `resource.push` */
  pushPropVal(t, e, r) {
    this.push(t, e, r);
  }
  /** Appends a Resource to a ResourceArray */
  push(t, e, r) {
    const o = this.get(t) ?? [];
    r && (e = e.filter((i) => !o.includes(i)).filter((i) => {
      var a;
      return !((a = this.commitBuilder.push[t]) != null && a.includes(i));
    }).filter((i, a, n) => n.indexOf(i) === a)), this.commitBuilder.addPushAction(t, ...e), this.propvals.set(t, [...o, ...e]);
  }
  /** @deprecated use `resource.remove()` */
  removePropVal(t) {
    this.remove(t);
  }
  /** Removes a property value combination from the resource and adds it to the next Commit */
  remove(t) {
    this.propvals.delete(t), this.commitBuilder.addRemoveAction(t);
  }
  /**
   * Removes a property value combination from this resource, does not store the
   * remove action in Commit
   */
  removePropValLocally(t) {
    this.propvals.delete(t);
  }
  /**
   * Commits the changes and sends the Commit to the resource's `/commit`
   * endpoint. Returns the Url of the created Commit. If you don't pass an Agent
   * explicitly, the default Agent of the Store is used.
   * When there are no changes no commit is made and the function returns Promise<undefined>.
   */
  async save(t) {
    var p, u;
    if (!this.commitBuilder.hasUnsavedChanges()) {
      console.warn(`No changes to ${this.subject}, not saving`);
      return;
    }
    const e = this.store.getAgent() ?? t;
    if (!e)
      throw new Error("No agent has been set or passed, you cannot save.");
    if (this.hasQueue)
      return;
    if (this.isParentNew()) {
      this.store.batchResource(this.subject);
      return;
    }
    if (this.inProgressCommit)
      return this.hasQueue = !0, await this.inProgressCommit, this.hasQueue = !1, this.inProgressCommit = void 0, this.save(t);
    const r = (p = this.get(U.commit.lastCommit)) == null ? void 0 : p.toString();
    r && this.commitBuilder.setPreviousCommit(r);
    const o = this.new;
    let i = () => {
    };
    this.inProgressCommit = new Promise((h) => {
      i = () => {
        h();
      };
    });
    const a = this.commitBuilder.clone();
    this.commitBuilder = new ot(this.subject);
    const n = await a.sign(
      e.privateKey,
      e.subject
    );
    this.appliedCommitSignatures.add(n.signature), this.loading = !1, this.new = !1;
    const c = new URL(this.subject).origin + "/commit";
    try {
      this.commitError = void 0, this.store.addResources(this, { skipCommitCompare: !0 });
      const h = await this.store.postCommit(n, c);
      return this.setUnsafe(U.commit.lastCommit, h.id), this.store.notifyResourceSaved(this), o && (this.store.subscribeWebSocket(this.subject), await this.store.saveBatchForParent(this.subject)), i(), h.id;
    } catch (h) {
      if (h.message.includes("previousCommit")) {
        console.warn("previousCommit missing or mismatch, retrying...");
        const f = (u = (await this.store.fetchResourceFromServer(
          this.subject
        )).get(U.commit.lastCommit)) == null ? void 0 : u.toString();
        return f && this.setUnsafe(U.commit.lastCommit, f), i(), await this.save(e);
      }
      throw this.commitBuilder = a, this.commitError = h, this.store.addResources(this, { skipCommitCompare: !0 }), i(), h;
    }
  }
  /**
   * Set a Property, Value combination and perform a validation. Will throw if
   * property is not valid for the datatype. Will fetch the datatype if it's not
   * available. Adds the property to the commitbuilder.
   *
   * When undefined is passed as value, the property is removed from the resource.
   */
  async set(t, e, r = !0) {
    if (this.store.isOffline() && r && (console.warn("Offline, not validating"), r = !1), r) {
      const o = await this.store.getProperty(t);
      try {
        fs(e, o.datatype);
      } catch (i) {
        throw i instanceof Error && (i.message = `Error validating ${o.shortname} with value ${e} for ${this.subject}: ${i.message}`), i;
      }
    }
    if (e === void 0) {
      this.remove(t), this.eventManager.emit("local-change", t, e);
      return;
    }
    this.propvals.set(t, e), this.commitBuilder.addSetAction(t, e), this.eventManager.emit("local-change", t, e);
  }
  /**
   * Set a Property, Value combination without performing validations or adding
   * it to the CommitBuilder.
   */
  setUnsafe(t, e) {
    this.propvals.set(t, e);
  }
  /** Sets the error on the Resource. Does not Throw. */
  setError(t) {
    this.error = t;
  }
  /** Set the Subject / ID URL of the Resource. Does not update the Store. */
  setSubject(t) {
    N.tryValidSubject(t), this.commitBuilder.setSubject(t), this._subject = t;
  }
  /** Refetches the resource from the server. Will reset all changes to the latest saved version */
  async refresh() {
    await this.store.fetchResourceFromServer(this.subject, {
      noWebSocket: !0
    });
  }
  isParentNew() {
    const t = this.propvals.get(A.properties.parent);
    return t ? this.store.getResourceLoading(t).new : !1;
  }
}
var Ss = /* @__PURE__ */ ((s) => (s.READ = "read", s.WRITE = "write", s))(Ss || {});
function fr(s) {
  return s.__internalObject !== s && console.warn("Attempted to proxy a proxy for " + s.subject), new Proxy(s.__internalObject, {});
}
const Rs = () => new Promise((s) => setTimeout(s));
class J {
  constructor() {
    this.parsedResources = [];
  }
  /**
   * Parses an JSON-AD object containing a resource. Returns the resource and a list of all the sub-resources it found.
   */
  parseObject(t, e) {
    return this.parsedResources = [], [this.parseJsonADResource(
      t,
      e
    ), [...this.parsedResources]];
  }
  /**
   * Parses an array of JSON-AD objects containing resources.
   * Returns a list of the resources in the array and a list of all the resources that were found including sub-resources.
   */
  parseArray(t) {
    return this.parsedResources = [], [this.parseJsonADArray(t), [...this.parsedResources]];
  }
  parseValue(t, e) {
    return this.parsedResources = [], [this.parseJsonAdResourceValue(t, e), [...this.parsedResources]];
  }
  parseJsonADResource(t, e = K) {
    const r = new L(e);
    this.parsedResources.push(r);
    try {
      for (const [o, i] of Object.entries(t)) {
        if (o === "@id") {
          if (typeof i != "string")
            throw new Error("'@id' field must be a string");
          if (r.subject !== "undefined" && r.subject !== K && i !== r.subject)
            throw new Error(
              `Resource has wrong subject in @id. Received subject was ${i}, expected ${r.subject}.`
            );
          r.setSubject(i);
          continue;
        }
        try {
          if (Lt(i)) {
            const a = i.map(
              (n) => this.parseJsonAdResourceValue(n, o)
            );
            r.setUnsafe(o, a);
          } else if (typeof i == "string")
            r.setUnsafe(o, i);
          else if (typeof i == "number")
            r.setUnsafe(o, i);
          else if (typeof i == "boolean")
            r.setUnsafe(o, i);
          else {
            const a = this.parseJsonAdResourceValue(i, o);
            r.setUnsafe(o, a);
          }
        } catch (a) {
          const c = `${`Failed creating value ${i} for key ${o} in resource ${r.subject}`}. ${a.message}`;
          throw new Error(c);
        }
      }
      r.loading = !1, r.hasClasses(wt.classes.error) && (r.error = j.fromResource(r));
    } catch (o) {
      throw o.message = "Failed parsing JSON " + o.message, r.setError(o), r.loading = !1, o;
    }
    return r;
  }
  parseJsonAdResourceValue(t, e) {
    if (typeof t == "string")
      return t;
    if ((t == null ? void 0 : t.constructor) === {}.constructor)
      if (Object.keys(t).includes("@id")) {
        const r = t["@id"];
        return this.parseJsonADResource(t), r;
      } else
        return t;
    throw new Error(
      `Value ${t} in ${e} not a string or a nested Resource`
    );
  }
  /** Parses a JSON-AD array, returns array of Resources */
  parseJsonADArray(t) {
    const e = [];
    try {
      for (const r of t) {
        const o = this.parseJsonADResource(r);
        e.push(o);
      }
    } catch (r) {
      throw r.message = "Failed parsing JSON " + r.message, r;
    }
    return e;
  }
}
ct.sha512 = (s) => Promise.resolve(ps(s));
function zt() {
  return Math.round((/* @__PURE__ */ new Date()).getTime());
}
class ot {
  /** Removes any query parameters from the Subject */
  constructor(t, e = {}) {
    this._subject = N.removeQueryParamsFromURL(t), this._set = e.set ?? /* @__PURE__ */ new Map(), this._push = e.push ?? /* @__PURE__ */ new Map(), this._remove = e.remove ?? /* @__PURE__ */ new Set(), this._destroy = e.destroy, this._previousCommit = e.previousCommit;
  }
  get subject() {
    return this._subject;
  }
  get set() {
    return this._set;
  }
  get push() {
    return this._push;
  }
  get remove() {
    return this._remove;
  }
  get destroy() {
    return this._destroy;
  }
  get previousCommit() {
    return this._previousCommit;
  }
  addSetAction(t, e) {
    return this.removeRemoveAction(t), this._set.set(t, e), this;
  }
  addPushAction(t, ...e) {
    const r = this._push.get(t) ?? /* @__PURE__ */ new Set();
    for (const o of e)
      r.add(o);
    return this._push.set(t, r), this;
  }
  addRemoveAction(t) {
    return this._set.delete(t), this._push.delete(t), this._remove.add(t), this;
  }
  removeRemoveAction(t) {
    return this._remove.delete(t), this;
  }
  setDestroy(t) {
    return this._destroy = t, this;
  }
  /**
   * Set the URL of the Commit that was previously (last) applied. The value of
   * this should probably be the `lastCommit` of the Resource.
   */
  setPreviousCommit(t) {
    return this._previousCommit = t, this;
  }
  setSubject(t) {
    return this._subject = t, this;
  }
  /**
   * Signs the commit using the privateKey of the Agent, and returns a full
   * Commit which is ready to be sent to an Atomic-Server `/commit` endpoint.
   */
  async sign(t, e) {
    return await this.signAt(
      e,
      t,
      zt()
    );
  }
  /** Returns true if the CommitBuilder has non-empty changes (set, remove, destroy) */
  hasUnsavedChanges() {
    return this.set.size > 0 || this.push.size > 0 || this.destroy || this.remove.size > 0;
  }
  /**
   * Creates a clone of the CommitBuilder. This is required, because I want to
   * prevent any adjustments to the CommitBuilder while signing, as this could
   * cause race conditions with wrong signatures
   */
  // Warning: I'm not sure whether this actually solves the issue. Might be a good idea to remove this.
  clone() {
    const t = {
      set: this.set,
      push: this.push,
      remove: this.remove,
      destroy: this.destroy,
      previousCommit: this.previousCommit
    };
    return new ot(this.subject, structuredClone(t));
  }
  toPlainObject() {
    return {
      subject: this.subject,
      set: Object.fromEntries(this.set.entries()),
      push: Object.fromEntries(
        Array.from(this.push.entries()).map(([t, e]) => [t, Array.from(e)])
      ),
      remove: Array.from(this.remove),
      destroy: this.destroy,
      previousCommit: this.previousCommit
    };
  }
  /** Creates a signature for a Commit using the private Key of some Agent. */
  async signAt(t, e, r) {
    if (t === void 0)
      throw new Error("No agent passed to sign commit");
    if (!this.hasUnsavedChanges())
      throw new Error(`No changes to commit in ${this.subject}`);
    const o = {
      ...this.clone().toPlainObject(),
      createdAt: r,
      signer: t
    }, i = fe({ ...o }), a = await ge(i, e);
    return {
      ...o,
      signature: a
    };
  }
}
function D(s, t, e) {
  t in s && t !== e && (Object.defineProperty(
    s,
    e,
    Object.getOwnPropertyDescriptor(s, t)
  ), delete s[t]);
}
function fe(s) {
  return s.remove && Object.keys(s.remove).length === 0 && delete s.remove, s.set && Object.keys(s.set).length === 0 && delete s.set, s.push && Object.keys(s.push).length === 0 && delete s.push, s.destroy === !1 && delete s.destroy, D(s, "createdAt", b.properties.commit.createdAt), D(s, "subject", b.properties.commit.subject), D(s, "set", b.properties.commit.set), D(s, "push", b.properties.commit.push), D(s, "signer", b.properties.commit.signer), D(s, "signature", b.properties.commit.signature), D(s, "remove", b.properties.commit.remove), D(s, "destroy", b.properties.commit.destroy), D(s, "previousCommit", b.properties.commit.previousCommit), s[b.properties.isA] = [b.classes.commit], Ke(s);
}
const ge = async (s, t) => {
  const e = ce(t), r = new Uint8Array(e), i = new TextEncoder().encode(s), a = await ze(i, r);
  return bt(a);
}, As = async (s) => {
  const t = ce(s), e = new Uint8Array(t), r = await ne(e);
  return bt(r);
};
async function gr() {
  const s = ct.randomPrivateKey(), t = await ne(s), e = bt(s);
  return {
    publicKey: bt(t),
    privateKey: e
  };
}
function xs(s) {
  return {
    id: s.getSubject(),
    subject: s.get(b.properties.commit.subject),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    set: s.get(b.properties.commit.set),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    push: s.get(b.properties.commit.push),
    signer: s.get(b.properties.commit.signer),
    createdAt: s.get(b.properties.commit.createdAt),
    remove: s.get(b.properties.commit.remove),
    destroy: s.get(b.properties.commit.destroy),
    signature: s.get(b.properties.commit.signature)
  };
}
function ye(s) {
  try {
    const t = JSON.parse(s);
    if (typeof t != "object")
      throw new Error("Commit is not an object");
    const e = t[b.properties.commit.subject], r = t[b.properties.commit.set], o = t[b.properties.commit.push], i = t[b.properties.commit.signer], a = t[b.properties.commit.createdAt], n = t[b.properties.commit.remove], c = t[b.properties.commit.destroy], p = t[b.properties.commit.signature], u = t["@id"], h = t[b.properties.commit.previousCommit];
    if (!p)
      throw new Error("Commit has no signature");
    return {
      subject: e,
      set: r,
      push: o,
      signer: i,
      createdAt: a,
      remove: n,
      destroy: c,
      signature: p,
      id: u,
      previousCommit: h
    };
  } catch (t) {
    throw new Error(`Could not parse commit: ${t}, Commit: ${s}`);
  }
}
function be(s, t) {
  const { set: e, remove: r, push: o } = t;
  return e && Cs(e, s), r && js(r, s), o && Ps(o, s), s;
}
function Es(s, t) {
  const e = ye(s), { subject: r, id: o, destroy: i, signature: a } = e;
  let n = t.resources.get(r);
  if (!n)
    n = new L(r);
  else if (n.appliedCommitSignatures.has(a))
    return;
  if (n = be(n, e), o && n.setUnsafe(U.commit.lastCommit, o), i) {
    t.removeResource(r);
    return;
  } else
    n.appliedCommitSignatures.add(a), t.addResources(n, { skipCommitCompare: !0 });
}
function Cs(s, t, e) {
  const r = new J(), o = [];
  for (const [i, a] of Object.entries(s)) {
    let n = a;
    if ((a == null ? void 0 : a.constructor) === {}.constructor) {
      const [c, p] = r.parseValue(a, i);
      n = c, o.push(...p);
    }
    Lt(a) && (n = a.map((c) => {
      const [p, u] = r.parseValue(c, i);
      return o.push(...u), p;
    })), t.setUnsafe(i, n);
  }
}
function js(s, t) {
  for (const e of s)
    t.removePropValLocally(e);
}
function Ps(s, t, e) {
  const r = new J(), o = [];
  for (const [i, a] of Object.entries(s)) {
    const n = t.get(i) || [], p = a.map((h) => {
      const [l, f] = r.parseValue(h, i);
      return o.push(...f), l;
    }), u = [...n, ...p];
    t.setUnsafe(i, u);
  }
}
async function we(s, t) {
  const e = zt();
  if (!t.subject)
    throw new Error("Agent has no subject, cannot authenticate");
  return {
    "https://atomicdata.dev/properties/auth/agent": t.subject,
    "https://atomicdata.dev/properties/auth/requestedSubject": s,
    "https://atomicdata.dev/properties/auth/publicKey": await t.getPublicKey(),
    "https://atomicdata.dev/properties/auth/timestamp": e,
    "https://atomicdata.dev/properties/auth/signature": await ve(
      s,
      t,
      e
    )
  };
}
async function ve(s, t, e) {
  const r = `${s} ${e}`;
  return await ge(r, t.privateKey);
}
function Us(s, t) {
  var e;
  return !s.startsWith("http://localhost") && ((e = t == null ? void 0 : t.subject) == null ? void 0 : e.startsWith("http://localhost"));
}
async function Qt(s, t, e) {
  const r = zt();
  return t != null && t.subject && !Us(s, t) && (e["x-atomic-public-key"] = await t.getPublicKey(), e["x-atomic-signature"] = await ve(
    s,
    t,
    r
  ), e["x-atomic-timestamp"] = r, e["x-atomic-agent"] = t == null ? void 0 : t.subject), e;
}
const _s = 24 * 60 * 60 * 1e3, Ns = (s, t, e, r = _s) => {
  const o = new Date(Date.now() + r).toUTCString(), i = encodeURIComponent(t), a = new URL(e).hostname, n = `${s}=${i};Expires=${o};Domain=${a};SameSite=Lax;path=/`;
  document.cookie = n;
}, Se = "atomic_session", Re = (s, t) => {
  we(s, t).then((e) => {
    Ns(Se, btoa(JSON.stringify(e)), s);
  });
}, Bs = () => {
  const s = document.cookie.match(
    /^(.*;)?\s*atomic_session\s*=\s*[^;]+(.*)?$/
  );
  return s ? s.length > 0 : !1;
}, Os = () => {
  document.cookie = `${Se}=;Max-Age=-99999999`;
}, ks = (s) => "blob" in s && "name" in s, Fs = "application/ad+json";
class N {
  constructor(t) {
    t && this.setFetch(t);
  }
  /** Throws an error if the subject is not valid */
  static tryValidSubject(t) {
    try {
      new URL(t);
    } catch (e) {
      throw new Error(`Not a valid URL: ${t}. ${e}`);
    }
  }
  /** Returns true if the given subject is valid */
  static isValidSubject(t) {
    if (typeof t != "string") return !1;
    try {
      return N.tryValidSubject(t), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Removes query params from the URL if it can build a URL. Will return the
   * normal URL if things go wrong.
   */
  // TODO: Not sure about this. Was done because `new Commit()` failed with `unknown-subject`.
  static removeQueryParamsFromURL(t) {
    return t == null ? void 0 : t.split("?")[0];
  }
  setFetch(t) {
    this.__fetchOverride = t.bind(globalThis);
  }
  /**
   * Fetches and Parses a Resource. Can fetch through another atomic server if you
   * pass the `from` argument, which should be the baseURL of an Atomic Server.
   * Returns a tuple of the requested resource and a list of all resources found in the response.
   */
  async fetchResourceHTTP(t, e = {}) {
    const { signInfo: r, from: o, body: i, method: a } = e;
    let n = [];
    const c = new J();
    let p = new L(t);
    try {
      N.tryValidSubject(t);
      const u = {};
      u.Accept = Fs, r && (ft() && t.startsWith(window.location.origin) ? Bs() || Re(r.serverURL, r.agent) : await Qt(t, r.agent, u));
      let h = t;
      if (o !== void 0) {
        const m = new URL(`${o}/path`);
        m.searchParams.set("path", t), h = m.href;
      }
      const l = await this.fetch(h, {
        headers: u,
        method: a ?? "GET",
        body: i
      }), f = await l.text();
      if (l.status === 200)
        try {
          const m = JSON.parse(f);
          if (e.noNested)
            p = m;
          else {
            const [y, S] = c.parseObject(
              m,
              t
            );
            p = y, n.push(...S);
          }
        } catch (m) {
          throw new j(
            `Could not parse JSON from fetching ${t}. Is it an Atomic Data resource? Error message: ${m.message}`
          );
        }
      else throw l.status === 401 ? new j(f, et.Unauthorized) : l.status === 500 ? new j(f, et.Server) : l.status === 404 ? new j(f, et.NotFound) : new j(f);
    } catch (u) {
      p.setError(u), n = [p], console.error(t, u);
    }
    return p.loading = !1, { resource: p, createdResources: n };
  }
  /** Posts a Commit to some endpoint. Returns the Commit created by the server. */
  async postCommit(t, e) {
    const r = fe({ ...t }), o = new Headers();
    o.set("Content-Type", "application/ad+json");
    let i;
    try {
      i = await this.fetch(e, {
        headers: o,
        method: "POST",
        body: r
      });
    } catch (n) {
      throw new j(`Posting Commit to ${e} failed: ${n}`);
    }
    const a = await i.text();
    if (i.status !== 200)
      throw new j(a, et.Server);
    return ye(a);
  }
  /**
   * Uploads files to the `/upload` endpoint of the Store. Signs the Headers using
   * the given agent.
   * Returns the newly created resources
   */
  async uploadFiles(t, e, r, o) {
    const i = new J(), a = new FormData();
    t.map((m) => {
      ks(m) ? a.append("assets", m.blob, m.name) : a.append("assets", m, m.name);
    });
    const n = new URL(`${e}/upload`);
    n.searchParams.set("parent", o);
    const c = await Qt(n.toString(), r, {}), p = {
      method: "POST",
      body: a,
      headers: c
    }, u = await this.fetch(n.toString(), p), h = await u.text();
    if (u.status !== 200)
      throw Error(h);
    const l = JSON.parse(h), [f] = i.parseArray(l);
    return f;
  }
  fetch(...t) {
    return this.__fetchOverride ? this.__fetchOverride(...t) : fetch(...t);
  }
}
class Ae {
  constructor(t, e) {
    if (e && N.tryValidSubject(e), !t)
      throw new j("Agent requires a private key");
    this.client = new N(), this.subject = e, this.privateKey = t;
  }
  /**
   * Parses a base64 JSON object containing a privateKey and subject, and
   * constructs an Agent from that.
   */
  static fromSecret(t) {
    const e = atob(t), r = JSON.parse(e), { privateKey: o, subject: i } = r;
    return new Ae(o, i);
  }
  /** Returns public key or generates one using the private key */
  async getPublicKey() {
    if (!this.publicKey) {
      const t = await As(this.privateKey);
      this.publicKey = t;
    }
    return this.publicKey;
  }
  /**
   * Returns a base64 encoded JSON object containing the Subject and the Private
   * Key. Used for signing in with one string
   */
  buildSecret() {
    const t = JSON.stringify(this);
    return btoa(t);
  }
  /** Fetches the public key for the agent, checks if it matches with the current one */
  async verifyPublicKeyWithServer() {
    var r;
    if (!this.subject)
      throw new j("Agent has no subject");
    const { resource: t } = await this.client.fetchResourceHTTP(this.subject);
    if (t.error)
      throw new Error(
        `Could not fetch agent, and could therefore not check validity of public key. ${t.error}`
      );
    if (((r = t.get(A.properties.publicKey)) == null ? void 0 : r.toString()) !== await this.getPublicKey())
      throw new Error(
        "Fetched publickey does not match current one - is the private key correct?"
      );
  }
}
const xe = (s) => {
  const t = new URL(s);
  return t.pathname = "search", t;
}, Ts = [
  "+",
  "^",
  "`",
  ":",
  "{",
  "}",
  '"',
  "[",
  "]",
  "(",
  ")",
  "!",
  "\\",
  "*",
  " ",
  // The dot is escaped, even though it's not in Tantivy's list.
  "."
];
function Is(s) {
  return s.replace(
    new RegExp(`([${Ts.join("\\")}])`, "g"),
    "\\$1"
  );
}
function Ms(s) {
  return Object.entries(s).map(([t, e]) => e && `${Is(t)}:"${e}"`).join(" AND ");
}
function $s(s, t, e = {}) {
  const { include: r = !1, limit: o = 30, parents: i, filters: a } = e, n = xe(s), c = a && Object.keys(a).length > 0 && Object.values(a).filter((p) => p && p.length > 0).length > 0;
  return t && n.searchParams.set("q", t), r && n.searchParams.set("include", r.toString()), o && n.searchParams.set("limit", o.toString()), c && n.searchParams.set("filters", Ms(a)), i && (Array.isArray(i) ? n.searchParams.append("parents", i.join(",")) : n.searchParams.append("parents", i)), n.toString();
}
function yr(s) {
  const t = xe(s.getServerUrl()).toString(), e = s.clientSideQuery(
    (r) => r.subject !== t && r.subject.startsWith(t)
  );
  for (const r of e)
    s.removeResource(r.subject);
}
function Nt(s) {
  if (!Ht(s))
    throw new Error("Parameter was not an error");
}
function Ht(s) {
  return !!s && typeof s == "object" && Ds(s) === "[object Error]" || s instanceof Error;
}
function Ds(s) {
  return Object.prototype.toString.call(s);
}
const Ls = "Layerr";
let Ws = Ls;
function zs() {
  return Ws;
}
function Hs(s) {
  let t, e = "";
  if (s.length === 0)
    t = {};
  else if (Ht(s[0]))
    t = {
      cause: s[0]
    }, e = s.slice(1).join(" ") || "";
  else if (s[0] && typeof s[0] == "object")
    t = Object.assign({}, s[0]), e = s.slice(1).join(" ") || "";
  else if (typeof s[0] == "string")
    t = {}, e = e = s.join(" ") || "";
  else
    throw new Error("Invalid arguments passed to Layerr");
  return {
    options: t,
    shortMessage: e
  };
}
class T extends Error {
  constructor(t, e) {
    const r = [...arguments], { options: o, shortMessage: i } = Hs(r);
    let a = i;
    if (o.cause && (a = `${a}: ${o.cause.message}`), super(a), this.message = a, o.name && typeof o.name == "string" ? this.name = o.name : this.name = zs(), o.cause && Object.defineProperty(this, "_cause", { value: o.cause }), Object.defineProperty(this, "_info", { value: {} }), o.info && typeof o.info == "object" && Object.assign(this._info, o.info), Error.captureStackTrace) {
      const n = o.constructorOpt || this.constructor;
      Error.captureStackTrace(this, n);
    }
  }
  static cause(t) {
    return Nt(t), t._cause && Ht(t._cause) ? t._cause : null;
  }
  static fullStack(t) {
    Nt(t);
    const e = T.cause(t);
    return e ? `${t.stack}
caused by: ${T.fullStack(e)}` : t.stack ?? "";
  }
  static info(t) {
    Nt(t);
    const e = {}, r = T.cause(t);
    return r && Object.assign(e, T.info(r)), t._info && Object.assign(e, t._info), e;
  }
  toString() {
    let t = this.name || this.constructor.name || this.constructor.prototype.name;
    return this.message && (t = `${t}: ${this.message}`), t;
  }
}
const Ee = "0123456789ABCDEFGHJKMNPQRSTVWXYZ", it = 32, te = 281474976710655, Vs = 10, Ks = 16, st = Object.freeze({
  source: "ulid"
});
function Gs(s) {
  const t = Js(), e = t && (t.crypto || t.msCrypto) || null;
  if (typeof (e == null ? void 0 : e.getRandomValues) == "function")
    return () => {
      const r = new Uint8Array(1);
      return e.getRandomValues(r), r[0] / 255;
    };
  if (typeof (e == null ? void 0 : e.randomBytes) == "function")
    return () => e.randomBytes(1).readUInt8() / 255;
  throw new T({
    info: {
      code: "PRNG_DETECT",
      ...st
    }
  }, "Failed to find a reliable PRNG");
}
function Js() {
  return Ys() ? self : typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : null;
}
function qs(s, t) {
  let e = "";
  for (; s > 0; s--)
    e = Xs(t) + e;
  return e;
}
function Zs(s, t) {
  if (isNaN(s))
    throw new T({
      info: {
        code: "ENC_TIME_NAN",
        ...st
      }
    }, `Time must be a number: ${s}`);
  if (s > te)
    throw new T({
      info: {
        code: "ENC_TIME_SIZE_EXCEED",
        ...st
      }
    }, `Cannot encode a time larger than ${te}: ${s}`);
  if (s < 0)
    throw new T({
      info: {
        code: "ENC_TIME_NEG",
        ...st
      }
    }, `Time must be positive: ${s}`);
  if (Number.isInteger(s) === !1)
    throw new T({
      info: {
        code: "ENC_TIME_TYPE",
        ...st
      }
    }, `Time must be an integer: ${s}`);
  let e, r = "";
  for (let o = t; o > 0; o--)
    e = s % it, r = Ee.charAt(e) + r, s = (s - e) / it;
  return r;
}
function Ys() {
  return typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
}
function Xs(s) {
  let t = Math.floor(s() * it);
  return t === it && (t = it - 1), Ee.charAt(t);
}
function Qs(s, t) {
  const e = Gs(), r = isNaN(s) ? Date.now() : s;
  return Zs(r, Vs) + qs(Ks, e);
}
function tr(s) {
  return s.toLowerCase().replace(/\s+/g, "-").replace(/-+/g, "-").replace(/[^\w-]+/g, "");
}
function ee(s, t) {
  const e = new URL(s);
  e.protocol === "http:" ? e.protocol = "ws" : e.protocol = "wss", e.pathname = "/ws";
  const r = new WebSocket(e.toString());
  return r.onopen = (o) => er(t, r), r.onmessage = (o) => sr(o, t), r.onerror = rr, r;
}
function er(s, t) {
  Ft(t, s).then(() => {
    for (const e of s.subscribers.keys())
      s.subscribeWebSocket(e);
  });
}
function sr(s, t) {
  if (s.data.startsWith("COMMIT ")) {
    const e = s.data.slice(7);
    Es(e, t);
  } else if (s.data.startsWith("ERROR "))
    t.notifyError(s.data.slice(6));
  else if (s.data.startsWith("RESOURCE ")) {
    const e = Ce(s);
    t.addResources(e);
  } else
    console.warn("Unknown websocket message:", s);
}
function rr(s) {
  console.error("websocket error:", s);
}
function Ce(s) {
  const t = s.data.slice(9), e = JSON.parse(t), r = new J(), [o, i] = r.parseObject(e);
  return i;
}
async function Ft(s, t, e = !1) {
  var i;
  const r = t.getAgent();
  if (!r || !r.subject)
    return;
  if (!s.url.startsWith("ws://localhost") && ((i = r == null ? void 0 : r.subject) != null && i.startsWith("http://localhost"))) {
    console.warn(
      `Can't authenticate localhost Agent over websocket with remote server ${s.url} because the server will nog be able to retrieve your Agent and verify your public key.`
    );
    return;
  }
  const o = await we(s.url, r);
  s.send("AUTHENTICATE " + JSON.stringify(o)), e && t.resources.forEach((a) => {
    (a.isUnauthorized() || a.loading) && t.fetchResourceFromServer(a.subject);
  });
}
const se = 5e3;
async function or(s, t) {
  return new Promise((e, r) => {
    s.addEventListener("message", function o(i) {
      const a = setTimeout(() => {
        s.removeEventListener("message", o), r(
          new Error(
            `Request for subject "${t}" timed out after ${se}ms.`
          )
        );
      }, se);
      i.data.startsWith("RESOURCE ") && Ce(i).forEach((n) => {
        n.subject === t && (clearTimeout(a), s.removeEventListener("message", o), e(n));
      });
    }), s.send("GET " + t);
  });
}
var ir = /* @__PURE__ */ ((s) => (s.ResourceSaved = "resource-saved", s.ResourceRemoved = "resource-removed", s.ResourceManuallyCreated = "resource-manually-created", s.AgentChanged = "agent-changed", s.ServerURLChanged = "server-url-changed", s.Error = "error", s))(ir || {});
const Bt = () => typeof WebSocket < "u";
class br {
  constructor(t = {}) {
    this.batchedResources = /* @__PURE__ */ new Map(), this.eventManager = new ue(), this._resources = /* @__PURE__ */ new Map(), this.webSockets = /* @__PURE__ */ new Map(), this.subscribers = /* @__PURE__ */ new Map(), t.serverUrl && this.setServerUrl(t.serverUrl), t.agent && this.setAgent(t.agent), this.client = new N(this.injectedFetch), this.getAgent = this.getAgent.bind(this), this.setAgent = this.setAgent.bind(this);
  }
  /** All the resources of the store */
  get resources() {
    return this._resources;
  }
  /** Inject a custom fetch implementation to use when fetching resources over http */
  injectFetch(t) {
    this.injectedFetch = t, this.client.setFetch(t);
  }
  addResources(t, e) {
    for (const r of Array.isArray(t) ? t : [t])
      this.addResource(r, e ?? {});
  }
  /**
   * @deprecated Will be marked private in the future, please use `addResources`
   *
   * Adds a Resource to the store and notifies subscribers. Replaces existing
   * resources, unless this new resource is explicitly incomplete.
   */
  addResource(t, { skipCommitCompare: e }) {
    if (t.setStore(this), t.get(A.properties.incomplete)) {
      const r = this.resources.get(t.subject);
      if (r && !r.loading)
        return;
    }
    if (!e) {
      const r = this.resources.get(t.subject);
      if (r && !r.hasClasses(Tt.classes.collection) && !r.loading && !r.new && r.get(Ot.properties.lastCommit) === t.get(Ot.properties.lastCommit))
        return;
    }
    this.resources.set(t.subject, t.__internalObject), this.notify(t.__internalObject);
  }
  /**
   * A helper function for creating new resources.
   * Options take:
   * subject (optional) - defaults to random subject,
   * parent (optional) - defaults to serverUrl,
   * isA (optional),
   * properties (optional) - any additional properties to be set on the resource.
   */
  async newResource({
    subject: t,
    parent: e,
    isA: r,
    propVals: o,
    noParent: i
  } = {}) {
    const a = Array.isArray(r) ? r : [r], n = t ?? this.createSubject(), c = this.getResourceLoading(n, { newResource: !0 });
    if (a[0] && await c.addClasses(...a), i || await c.set(A.properties.parent, e ?? this.serverUrl), o)
      for (const [p, u] of Object.entries(o))
        await c.set(p, u);
    return c;
  }
  async search(t, e = {}) {
    const r = $s(this.serverUrl, t, e);
    return (await this.fetchResourceFromServer(r, {
      noWebSocket: !0
    })).get(wt.properties.results) ?? [];
  }
  /** Checks if a subject is free to use */
  async checkSubjectTaken(t) {
    var r;
    const e = this.resources.get(t);
    if (e != null && e.isReady() && !(e != null && e.new))
      return !0;
    try {
      const o = this.agent ? { agent: this.agent, serverURL: this.getServerUrl() } : void 0, { createdResources: i } = await this.client.fetchResourceHTTP(
        t,
        {
          method: "GET",
          signInfo: o
        }
      );
      if ((r = i.find((a) => a.subject === t)) != null && r.isReady())
        return !0;
    } catch {
    }
    return !1;
  }
  /**
   * Checks is a set of URL parts can be combined into an available subject.
   * Will retry until it works.
   */
  async buildUniqueSubjectFromParts(t, e) {
    const r = t.map((i) => tr(i)).join("/"), o = e ?? this.getServerUrl();
    return this.findAvailableSubject(r, o);
  }
  /** Creates a random subject url. You can pass a parent subject if you want that to be included in the url. */
  createSubject(t) {
    return t ? `${t}/${this.randomPart()}` : new URL(`/${this.randomPart()}`, this.serverUrl).toString();
  }
  /**
   * Always fetches resource from the server then adds it to the store.
   */
  async fetchResourceFromServer(t, e = {}) {
    if (e.setLoading) {
      const o = new L(t);
      o.loading = !0, this.addResources(o, { skipCommitCompare: !0 });
    }
    const r = this.getWebSocketForSubject(t);
    if (!e.fromProxy && !e.noWebSocket && Bt() && (r == null ? void 0 : r.readyState) === WebSocket.OPEN)
      await or(r, t);
    else {
      const o = this.agent ? { agent: this.agent, serverURL: this.getServerUrl() } : void 0, { createdResources: i } = await this.client.fetchResourceHTTP(
        t,
        {
          from: e.fromProxy ? this.getServerUrl() : void 0,
          method: e.method,
          body: e.body,
          signInfo: o
        }
      );
      this.addResources(i, { skipCommitCompare: !0 });
    }
    return this.resources.get(t);
  }
  getAllSubjects() {
    return Array.from(this.resources.keys());
  }
  /** Returns the WebSocket for the current Server URL */
  getDefaultWebSocket() {
    return this.webSockets.get(this.getServerUrl());
  }
  /** Opens a Websocket for some subject URL, or returns the existing one. */
  getWebSocketForSubject(t) {
    const e = new URL(t), r = this.webSockets.get(e.origin);
    if (r)
      return r;
    typeof window < "u" && this.webSockets.set(e.origin, ee(e.origin, this));
  }
  /** Returns the base URL of the companion server */
  getServerUrl() {
    return this.serverUrl;
  }
  /**
   * Returns the Currently set Agent, returns null if there is none. Make sure
   * to first run `store.setAgent()`.
   */
  getAgent() {
    return this.agent ?? void 0;
  }
  /**
   * Gets a resource by URL. Fetches and parses it if it's not available in the
   * store. Instantly returns an empty loading resource, while the fetching is
   * done in the background . If the subject is undefined, an empty non-saved
   * resource will be returned.
   */
  getResourceLoading(t = K, e = {}) {
    if (t === K || t === null) {
      const o = new L(K, e.newResource);
      return o.setStore(this), o;
    }
    let r = this.resources.get(t);
    if (r)
      !e.allowIncomplete && r.loading === !1 && r.get(A.properties.incomplete) && (r.loading = !0, this.addResources(r), this.fetchResourceFromServer(t, e));
    else return r = new L(t, e.newResource), r.loading = !0, this.addResources(r), e.newResource || this.fetchResourceFromServer(t, e), r;
    return r;
  }
  /**
   * @deprecated
   * renamed to `getResource`
   */
  async getResourceAsync(t) {
    return this.getResource(t);
  }
  /**
   * Gets a resource by URL. Fetches and parses it if it's not available in the
   * store. Not recommended to use this for rendering, because it might cause
   * resources to be fetched multiple times.
   */
  async getResource(t) {
    const e = this.resources.get(t);
    if (e && e.isReady())
      return e;
    if (e && !e.isReady())
      return new Promise((o, i) => {
        const n = (c) => {
          this.unsubscribe(t, n), o(c);
        };
        this.subscribe(t, n), setTimeout(() => {
          this.unsubscribe(t, n), i(
            new Error(
              `Async Request for subject "${t}" timed out after 5000ms.`
            )
          );
        }, 5e3);
      });
    const r = await this.fetchResourceFromServer(t);
    return this.subscribeWebSocket(t), r;
  }
  /** Gets a property by URL. */
  async getProperty(t) {
    var c;
    const e = await this.getResource(t);
    if (e === void 0)
      throw Error(`Property ${t} is not found`);
    if (e.error)
      throw Error(`Property ${t} cannot be loaded: ${e.error}`);
    const r = e.get(A.properties.datatype);
    if (r === void 0)
      throw Error(
        `Property ${t} has no datatype: ${e.getPropVals()}`
      );
    const o = e.get(A.properties.shortname);
    if (o === void 0)
      throw Error(
        `Property ${t} has no shortname: ${e.getPropVals()}`
      );
    const i = e.get(A.properties.description);
    if (i === void 0)
      throw Error(
        `Property ${t} has no description: ${e.getPropVals()}`
      );
    const a = (c = e.get(A.properties.classtype)) == null ? void 0 : c.toString();
    return {
      subject: t,
      classType: a,
      shortname: o.toString(),
      description: i.toString(),
      datatype: us(r.toString()),
      allowsOnly: e.get(A.properties.allowsOnly)
    };
  }
  /**
   * This is called when Errors occur in some of the library functions.
   */
  notifyError(t) {
    const e = t instanceof Error ? t : new Error(t);
    if (this.eventManager.hasSubscriptions(
      "error"
      /* Error */
    ))
      this.eventManager.emit("error", e);
    else
      throw e;
  }
  /**
   * If the store does not have an active internet connection, will return
   * false. This may affect some functionality. For example, some checks will
   * not be performed client side when offline.
   */
  isOffline() {
    var t;
    return ft() ? !((t = window == null ? void 0 : window.navigator) != null && t.onLine) : !1;
  }
  async notifyResourceSaved(t) {
    await this.eventManager.emit("resource-saved", t);
  }
  async notifyResourceManuallyCreated(t) {
    await this.eventManager.emit("resource-manually-created", t);
  }
  /** Parses the HTML document for `JSON-AD` data in <meta> tags, adds it to the store */
  parseMetaTags() {
    const t = document.querySelectorAll(
      'meta[property="json-ad-initial"]'
    ), e = new J();
    t.forEach((r) => {
      const o = r.getAttribute("content");
      if (o === null)
        return;
      const i = JSON.parse(atob(o)), [a, n] = e.parseObject(i);
      this.addResources(n);
    });
  }
  /**
   * Fetches all Classes and Properties from your current server, including external resources.
   * This helps to speed up time to interactive, but may not be necessary for all applications.
   */
  async preloadPropsAndClasses() {
    const t = new URL("/classes", this.serverUrl), e = new URL("/properties", this.serverUrl);
    t.searchParams.set("include_external", "true"), e.searchParams.set("include_external", "true"), t.searchParams.set("include_nested", "true"), e.searchParams.set("include_nested", "true"), t.searchParams.set("page_size", "999"), e.searchParams.set("page_size", "999"), await Promise.all([
      this.fetchResourceFromServer(t.toString()),
      this.fetchResourceFromServer(e.toString())
    ]);
  }
  /** Sends an HTTP POST request to the server to the Subject. Parses the returned Resource and adds it to the store. */
  async postToServer(t, e) {
    return this.fetchResourceFromServer(t, {
      body: e,
      noWebSocket: !0,
      method: "POST"
    });
  }
  /** Removes (destroys / deletes) resource from this store */
  removeResource(t) {
    const e = this.resources.get(t);
    e && (this.resources.delete(t), this.eventManager.emit("resource-removed", e));
  }
  /**
   * Changes the Subject of a Resource. Checks if the new name is already taken,
   * errors if so.
   */
  async renameSubject(t, e) {
    N.tryValidSubject(e);
    const r = t.subject;
    if (await this.checkSubjectTaken(e))
      throw Error(`New subject name is already taken: ${e}`);
    t.setSubject(e);
    const o = this.subscribers.get(r) ?? [];
    this.subscribers.set(e, o), this.removeResource(r), this.addResources(t);
  }
  /**
   * Sets the current Agent, used for signing commits. Authenticates all open
   * websockets, and retries previously failed fetches.
   *
   * Warning: doing this stores the Private Key of the Agent in memory. This
   * might have security implications for your application.
   */
  setAgent(t) {
    this.agent = t, t && t.subject ? (ft() && Re(this.serverUrl, t), this.webSockets.forEach((e) => {
      e.readyState === e.OPEN ? Ft(e, this, !0) : e.onopen = () => {
        Ft(e, this, !0);
      };
    })) : ft() && Os(), this.eventManager.emit("agent-changed", t);
  }
  /** Sets the Server base URL, without the trailing slash. */
  setServerUrl(t) {
    if (N.tryValidSubject(t), t.substring(-1) === "/")
      throw Error("baseUrl should not have a trailing slash");
    this.serverUrl = t, this.eventManager.emit("server-url-changed", t), Bt() && this.openWebSocket(t);
  }
  /** Opens a WebSocket for this Atomic Server URL */
  openWebSocket(t) {
    if (Bt()) {
      if (this.webSockets.has(t))
        return;
      this.webSockets.set(t, ee(t, this));
    } else
      console.warn("WebSockets not supported, no window available");
  }
  /**
   * Registers a callback for when the a resource is updated. When you call
   * this
   * The method returns a function that you can call to unsubscribe. You can also unsubscribe by calling `store.unsubscribe()`.
   */
  // TODO: consider subscribing to properties, maybe add a second subscribe function, use that in useValue
  subscribe(t, e) {
    if (t === void 0)
      throw Error("Cannot subscribe to undefined subject");
    let r = this.subscribers.get(t);
    return r === void 0 && (this.subscribeWebSocket(t), r = []), r.push(e), this.subscribers.set(t, r), () => {
      this.unsubscribe(t, e);
    };
  }
  subscribeWebSocket(t) {
    if (t !== K)
      try {
        const e = this.getWebSocketForSubject(t);
        (e == null ? void 0 : e.readyState) === 1 && (e == null || e.send(`SUBSCRIBE ${t}`));
      } catch (e) {
        console.error(e);
      }
  }
  unSubscribeWebSocket(t) {
    var e;
    if (t !== K)
      try {
        (e = this.getDefaultWebSocket()) == null || e.send(`UNSUBSCRIBE ${t}`);
      } catch (r) {
        console.error(r);
      }
  }
  /** Unregisters the callback (see `subscribe()`) */
  unsubscribe(t, e) {
    if (t === void 0)
      return;
    let r = this.subscribers.get(t);
    r && (r = r == null ? void 0 : r.filter((o) => o !== e), this.subscribers.set(t, r));
  }
  on(t, e) {
    return this.eventManager.register(t, e);
  }
  /** Uploads files to atomic server and create resources for them, then returns the subjects.
   * If using this in Node.js and it does not work, try injecting node-fetch using `Store.injectFetch()` Some versions of Node create mallformed FormData when using the build-in fetch.
   */
  async uploadFiles(t, e) {
    const r = this.getAgent();
    if (!r)
      throw Error("No agent set, cannot upload files");
    const o = await this.client.uploadFiles(
      t,
      this.getServerUrl(),
      r,
      e
    );
    return this.addResources(o), o.map((i) => i.subject);
  }
  /** Posts a Commit to some endpoint. Returns the Commit created by the server. */
  async postCommit(t, e) {
    return this.client.postCommit(t, e);
  }
  /**
   * Returns the ancestry of a resource, starting with the resource itself.
   */
  async getResourceAncestry(t) {
    const e = [t.subject];
    let r = t.get(A.properties.parent);
    for (r && e.push(r); r; ) {
      const o = await this.getResource(r);
      if (o) {
        if (r = o.get(A.properties.parent), e.includes(r))
          throw new Error(
            `Resource ${t.subject} ancestry is cyclical. ${r} is already in the ancestry}`
          );
        e.push(r);
      }
    }
    return e;
  }
  /**
   * Returns a list of resources currently in the store which pass the given filter function.
   * This is a client-side filter, and does not query the server.
   */
  clientSideQuery(t) {
    return Array.from(this.resources.values()).filter(t);
  }
  /**
   * @Internal
   * Add the resource to a batch that is saved when the parent is saved. Only gets saved when the parent is new.
   */
  batchResource(t) {
    const e = this._resources.get(t);
    if (!e)
      throw new Error(
        `Resource ${t} can not be saved because it is not in the store.`
      );
    const r = e.get(A.properties.parent);
    if (r === void 0)
      throw new Error(
        `Resource ${t} can not be added to a batch because it's missing a parent.`
      );
    this.batchedResources.has(r) ? this.batchedResources.get(r).add(t) : this.batchedResources.set(r, /* @__PURE__ */ new Set([t]));
  }
  /**
   * @Internal
   * Saves all resources that are in a batch for a parent.
   */
  async saveBatchForParent(t) {
    const e = this.batchedResources.get(t);
    if (e) {
      for (const r of e) {
        const o = this._resources.get(r);
        await (o == null ? void 0 : o.save());
      }
      this.batchedResources.delete(t);
    }
  }
  async importJsonAD(t, e) {
    const r = new URL(me.import, this.serverUrl);
    r.searchParams.set("parent", e.parent), r.searchParams.set(
      "overwrite-outside",
      e.overwriteOutside ? "true" : "false"
    );
    const o = await this.postToServer(r.toString(), t);
    if (o.error)
      throw o.error;
  }
  randomPart() {
    return Qs().toLowerCase();
  }
  async findAvailableSubject(t, e, r = !0) {
    let o = new URL(`${e}/${t}`).toString();
    if (!r) {
      const a = this.randomPart();
      o += `-${a}`;
    }
    return await this.checkSubjectTaken(o) ? this.findAvailableSubject(t, e, !1) : o;
  }
  /** Lets subscribers know that a resource has been changed. Time to update your views.
   * Make sure the resource is a new reference, otherwise React will not rerender.
   */
  async notify(t) {
    const e = t.subject, r = this.subscribers.get(e);
    r !== void 0 && Promise.allSettled(r.map(async (o) => o(t)));
  }
}
function wr(s, t, e) {
  let r = s.replace(/(^\w+:|^)\/\//, "");
  if (typeof window < "u" && (window != null && window.location) && r.startsWith(window.location.hostname) && (r = r.slice(window.location.hostname.length)), r.length <= t)
    return r;
  if (e) {
    const o = r.length - t;
    return "..." + r.slice(o);
  }
  return r.slice(0, t) + "...";
}
Ne();
export {
  Ae as Agent,
  j as AtomicError,
  N as Client,
  Wt as Collection,
  ys as CollectionBuilder,
  ot as CommitBuilder,
  pe as Datatype,
  et as ErrorType,
  J as JSONADParser,
  L as Resource,
  vs as ResourceEvents,
  Ss as RightType,
  br as Store,
  ir as StoreEvents,
  ar as __INTERNAL_GET_KNOWN_SUBJECT_MAPPING,
  be as applyCommitToResource,
  $s as buildSearchSubject,
  Bs as checkAuthenticationCookie,
  bs as classes,
  Tt as collections,
  Ot as commits,
  A as core,
  we as createAuthentication,
  _e as dataBrowser,
  us as datatypeFromUrl,
  ws as datatypes,
  me as endpoints,
  Is as escapeTantivyKey,
  gr as generateKeyPair,
  As as generatePublicKeyFromPrivate,
  Ue as getKnownNameBySubject,
  zt as getTimestampNow,
  le as instances,
  Lt as isArray,
  cr as isAtomicError,
  he as isNumber,
  Q as isString,
  gs as isUnauthorized,
  Es as parseAndApplyCommit,
  ye as parseCommitJSON,
  xs as parseCommitResource,
  U as properties,
  dr as proxyCollection,
  fr as proxyResource,
  Pe as registerOntologies,
  yr as removeCachedSearchResults,
  Os as removeCookieAuthentication,
  nr as reverseDatatypeMapping,
  fe as serializeDeterministically,
  wt as server,
  Re as setCookieAuthentication,
  Qt as signRequest,
  ge as signToBase64,
  ve as signatureMessage,
  wr as truncateUrl,
  K as unknownSubject,
  b as urls,
  _t as valToArray,
  pr as valToBoolean,
  hr as valToDate,
  ur as valToNumber,
  mr as valToResource,
  lr as valToString,
  fs as validateDatatype
};
