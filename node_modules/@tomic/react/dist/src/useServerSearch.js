var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { buildSearchSubject, removeCachedSearchResults, urls, } from '@tomic/lib';
import { useEffect, useMemo, useState } from 'react';
import { useArray, useDebounce, useResource, useServerURL, useStore, } from './index.js';
var noResultsResult = {
    results: [],
    loading: false,
    error: undefined,
};
/** Escape values for use in filter string */
export var escapeFilterValue = function (value) {
    return value.replace(/[+^`:{}"[\]()!\\*\s]/gm, '\\$&');
};
/** Pass a query to search the current server */
export function useServerSearch(query, opts) {
    var _a;
    if (opts === void 0) { opts = {}; }
    var _b = opts.debounce, debounce = _b === void 0 ? 50 : _b;
    var store = useStore();
    var _c = __read(useState([]), 2), results = _c[0], setResults = _c[1];
    var _d = __read(useServerURL(), 1), serverURL = _d[0];
    // Calculating the query takes a while, so we debounce it
    var debouncedQuery = (_a = useDebounce(query, debounce)) !== null && _a !== void 0 ? _a : '';
    var searchSubjectURL = useMemo(function () { return buildSearchSubject(serverURL, debouncedQuery, opts); }, [debouncedQuery, opts, serverURL]);
    var resource = useResource(searchSubjectURL, {
        noWebSocket: true,
    });
    var _e = __read(useArray(resource, urls.properties.endpoint.results), 1), resultsIn = _e[0];
    // Only set new results if the resource is no longer loading, which improves UX
    useEffect(function () {
        if (!resource.loading && resultsIn) {
            setResults(resultsIn);
        }
    }, [
        // Prevent re-rendering if the resultsIn is the same
        resultsIn === null || resultsIn === void 0 ? void 0 : resultsIn.toString(),
        resource.loading,
    ]);
    // Remove cached results when component unmounts.
    useEffect(function () {
        return function () {
            removeCachedSearchResults(store);
        };
    }, []);
    var result = useMemo(function () { return ({
        results: results,
        loading: resource.loading,
        error: resource.error,
    }); }, [results, resource.loading, resource.error]);
    if (!query && !opts.allowEmptyQuery) {
        return noResultsResult;
    }
    // Return the width so we can use it in our components
    return result;
}
//# sourceMappingURL=useServerSearch.js.map