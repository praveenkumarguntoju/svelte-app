import {
  __commonJS,
  __toESM
} from "./chunk-NNIHVWYK.js";

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
        self2 = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          oldElement._owner,
          oldElement.props,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (i === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return ctor = payload._result, void 0 === ctor && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ctor
          ), "default" in ctor || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ctor
          ), ctor.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function noop() {
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module2 && module2[requireString]).call(
              module2,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error) {
              ReactSharedInternals.thrownErrors.push(error);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i] = callback;
                    queue.splice(0, i);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error) {
            queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      }, fnName;
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null,
        actQueue: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        "react-stack-bottom-frame": function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs["react-stack-bottom-frame"].bind(deprecatedAPIs, UnknownOwner)();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error) {
          ReactSharedInternals.thrownErrors.push(error);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i = 0; i < propName; i++)
            JSCompiler_inline_result[i] = arguments[i + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          void 0,
          void 0,
          owner,
          props,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          owner = arguments[key], isValidElement(owner) && owner._store && (owner._store.validated = 1);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        for (var i = 2; i < arguments.length; i++) {
          var node = arguments[i];
          isValidElement(node) && node._store && (node._store.validated = 1);
        }
        i = {};
        node = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), node = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
            childArray[_i] = arguments[_i + 2];
          Object.freeze && Object.freeze(childArray);
          i.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i[propName] && (i[propName] = childrenLength[propName]);
        node && defineKeyPropWarningGetter(
          i,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          node,
          void 0,
          void 0,
          getOwner(),
          i,
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        var dispatcher = resolveDispatcher();
        if ("function" === typeof update)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.1.0";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/@tomic/react/dist/src/hooks.js
var import_react = __toESM(require_react(), 1);

// node_modules/@tomic/lib/dist/index.js
var gt = /* @__PURE__ */ new Map();
function Pe(...s) {
  for (const t of s) {
    for (const [e, r] of Object.entries(t.classes))
      gt.set(r, e);
    for (const [e, r] of Object.entries(t.properties))
      gt.set(r, e);
  }
}
function Ue(s) {
  return gt.get(s);
}
function ar() {
  return gt;
}
var A = {
  classes: {
    class: "https://atomicdata.dev/classes/Class",
    property: "https://atomicdata.dev/classes/Property",
    agent: "https://atomicdata.dev/classes/Agent",
    datatype: "https://atomicdata.dev/classes/Datatype",
    ontology: "https://atomicdata.dev/class/ontology"
  },
  properties: {
    allowsOnly: "https://atomicdata.dev/properties/allowsOnly",
    classtype: "https://atomicdata.dev/properties/classtype",
    datatype: "https://atomicdata.dev/properties/datatype",
    description: "https://atomicdata.dev/properties/description",
    incomplete: "https://atomicdata.dev/properties/incomplete",
    isA: "https://atomicdata.dev/properties/isA",
    isDynamic: "https://atomicdata.dev/properties/isDynamic",
    name: "https://atomicdata.dev/properties/name",
    parent: "https://atomicdata.dev/properties/parent",
    read: "https://atomicdata.dev/properties/read",
    recommends: "https://atomicdata.dev/properties/recommends",
    requires: "https://atomicdata.dev/properties/requires",
    shortname: "https://atomicdata.dev/properties/shortname",
    write: "https://atomicdata.dev/properties/write",
    publicKey: "https://atomicdata.dev/properties/publicKey",
    instances: "https://atomicdata.dev/properties/instances",
    properties: "https://atomicdata.dev/properties/properties",
    classes: "https://atomicdata.dev/properties/classes",
    isLocked: "https://atomicdata.dev/properties/isLocked",
    localId: "https://atomicdata.dev/properties/localId"
  }
};
var Ot = {
  classes: {
    commit: "https://atomicdata.dev/classes/Commit"
  },
  properties: {
    subject: "https://atomicdata.dev/properties/subject",
    createdAt: "https://atomicdata.dev/properties/createdAt",
    lastCommit: "https://atomicdata.dev/properties/lastCommit",
    previousCommit: "https://atomicdata.dev/properties/previousCommit",
    signer: "https://atomicdata.dev/properties/signer",
    set: "https://atomicdata.dev/properties/set",
    push: "https://atomicdata.dev/properties/push",
    remove: "https://atomicdata.dev/properties/remove",
    destroy: "https://atomicdata.dev/properties/destroy",
    signature: "https://atomicdata.dev/properties/signature"
  }
};
var Tt = {
  classes: {
    collection: "https://atomicdata.dev/classes/Collection"
  },
  properties: {
    members: "https://atomicdata.dev/properties/collection/members",
    currentPage: "https://atomicdata.dev/properties/collection/currentPage",
    pageSize: "https://atomicdata.dev/properties/collection/pageSize",
    property: "https://atomicdata.dev/properties/collection/property",
    totalMembers: "https://atomicdata.dev/properties/collection/totalMembers",
    totalPages: "https://atomicdata.dev/properties/collection/totalPages",
    value: "https://atomicdata.dev/properties/collection/value",
    sortBy: "https://atomicdata.dev/properties/collection/sortBy",
    sortDesc: "https://atomicdata.dev/properties/collection/sortDesc",
    includeExternal: "https://atomicdata.dev/properties/collection/includeExternal"
  }
};
var _e = {
  classes: {
    article: "https://atomicdata.dev/classes/Article",
    bookmark: "https://atomicdata.dev/class/Bookmark",
    chatroom: "https://atomicdata.dev/classes/ChatRoom",
    currencyProperty: "https://atomicdata.dev/ontology/data-browser/class/currency-property",
    dateFormat: "https://atomicdata.dev/classes/DateFormat",
    displayStyle: "https://atomicdata.dev/class/DisplayStyle",
    document: "https://atomicdata.dev/classes/Document",
    floatRangeProperty: "https://atomicdata.dev/classes/FloatRangeProperty",
    folder: "https://atomicdata.dev/classes/Folder",
    formattedDate: "https://atomicdata.dev/classes/FormattedDate",
    formattedNumber: "https://atomicdata.dev/classes/FormattedNumber",
    importer: "https://atomicdata.dev/classes/Importer",
    message: "https://atomicdata.dev/classes/Message",
    numberFormat: "https://atomicdata.dev/classes/NumberFormat",
    paragraph: "https://atomicdata.dev/classes/elements/Paragraph",
    rangeProperty: "https://atomicdata.dev/classes/RangeProperty",
    selectProperty: "https://atomicdata.dev/classes/SelectProperty",
    table: "https://atomicdata.dev/classes/Table",
    tag: "https://atomicdata.dev/classes/Tag",
    template: "https://atomicdata.dev/ontology/data-browser/class/template"
  },
  properties: {
    color: "https://atomicdata.dev/properties/color",
    currency: "https://atomicdata.dev/ontology/data-browser/property/currency",
    customNodePositioning: "https://atomicdata.dev/properties/custom-node-positioning",
    dateFormat: "https://atomicdata.dev/properties/dateFormat",
    decimalPlaces: "https://atomicdata.dev/properties/decimalPlaces",
    displayStyle: "https://atomicdata.dev/property/display-style",
    elements: "https://atomicdata.dev/properties/documents/elements",
    emoji: "https://atomicdata.dev/properties/emoji",
    image: "https://atomicdata.dev/ontology/data-browser/property/image",
    imageUrl: "https://atomicdata.dev/properties/imageUrl",
    max: "https://atomicdata.dev/properties/max",
    maxFloat: "https://atomicdata.dev/properties/maxFloat",
    messages: "https://atomicdata.dev/properties/messages",
    min: "https://atomicdata.dev/properties/min",
    minFloat: "https://atomicdata.dev/properties/minFloat",
    nextPage: "https://atomicdata.dev/properties/nextPage",
    numberFormatting: "https://atomicdata.dev/properties/numberFormatting",
    preview: "https://atomicdata.dev/property/preview",
    publishedAt: "https://atomicdata.dev/properties/published-at",
    replyTo: "https://atomicdata.dev/properties/replyTo",
    resources: "https://atomicdata.dev/ontology/data-browser/property/resources",
    subResources: "https://atomicdata.dev/properties/subresources",
    tableColumnWidths: "https://atomicdata.dev/properties/tableColumnWidths",
    tags: "https://atomicdata.dev/properties/tags",
    url: "https://atomicdata.dev/property/url"
  }
};
var wt = {
  classes: {
    error: "https://atomicdata.dev/classes/Error",
    endpoint: "https://atomicdata.dev/classes/Endpoint",
    drive: "https://atomicdata.dev/classes/Drive",
    redirect: "https://atomicdata.dev/classes/Redirect",
    file: "https://atomicdata.dev/classes/File",
    invite: "https://atomicdata.dev/classes/Invite",
    endpointResponse: "https://atomicdata.dev/ontology/server/class/endpoint-response"
  },
  properties: {
    drives: "https://atomicdata.dev/properties/drives",
    results: "https://atomicdata.dev/properties/endpoint/results",
    property: "https://atomicdata.dev/properties/search/property",
    redirectAgent: "https://atomicdata.dev/properties/invite/redirectAgent",
    agent: "https://atomicdata.dev/properties/invite/agent",
    publicKey: "https://atomicdata.dev/properties/invite/publicKey",
    target: "https://atomicdata.dev/properties/invite/target",
    usagesLeft: "https://atomicdata.dev/properties/invite/usagesLeft",
    users: "https://atomicdata.dev/properties/invite/users",
    write: "https://atomicdata.dev/properties/invite/write",
    filename: "https://atomicdata.dev/properties/filename",
    filesize: "https://atomicdata.dev/properties/filesize",
    downloadUrl: "https://atomicdata.dev/properties/downloadURL",
    mimetype: "https://atomicdata.dev/properties/mimetype",
    attachments: "https://atomicdata.dev/properties/attachments",
    createdBy: "https://atomicdata.dev/properties/createdBy",
    checksum: "https://atomicdata.dev/properties/checksum",
    internalId: "https://atomicdata.dev/properties/internalId",
    children: "https://atomicdata.dev/properties/children",
    parameters: "https://atomicdata.dev/properties/endpoint/parameters",
    destination: "https://atomicdata.dev/properties/destination",
    status: "https://atomicdata.dev/ontology/server/property/status",
    responseMessage: "https://atomicdata.dev/ontology/server/property/response-message",
    defaultOntology: "https://atomicdata.dev/ontology/server/property/default-ontology",
    imageWidth: "https://atomicdata.dev/properties/imageWidth",
    imageHeight: "https://atomicdata.dev/properties/imageHeight"
  }
};
function Ne() {
  Pe(A, Ot, Tt, _e, wt);
}
function ft() {
  return globalThis === globalThis.window;
}
var Be = {};
var E = BigInt(0);
var g = BigInt(1);
var C = BigInt(2);
var re = BigInt(255);
var Kt = C ** BigInt(252) + BigInt("27742317777372353535851937790883648493");
var R = {
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: C ** re - BigInt(19),
  l: Kt,
  n: Kt,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
};
var oe = C ** BigInt(256);
var rt = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var Oe = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var ke = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var Fe = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var Te = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var w = class _w {
  constructor(t, e, r, o) {
    this.x = t, this.y = e, this.z = r, this.t = o;
  }
  static fromAffine(t) {
    if (!(t instanceof x))
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    return t.equals(x.ZERO) ? _w.ZERO : new _w(t.x, t.y, g, d(t.x * t.y));
  }
  static toAffineBatch(t) {
    const e = $e(t.map((r) => r.z));
    return t.map((r, o) => r.toAffine(e[o]));
  }
  static normalizeZ(t) {
    return this.toAffineBatch(t).map(this.fromAffine);
  }
  equals(t) {
    Gt(t);
    const { x: e, y: r, z: o } = this, { x: i, y: a, z: n } = t, c = d(e * n), p = d(i * o), u = d(r * n), h = d(a * o);
    return c === p && u === h;
  }
  negate() {
    return new _w(d(-this.x), this.y, this.z, d(-this.t));
  }
  double() {
    const { x: t, y: e, z: r } = this, { a: o } = R, i = d(t ** C), a = d(e ** C), n = d(C * d(r ** C)), c = d(o * i), p = d(d((t + e) ** C) - i - a), u = c + a, h = u - n, l = c - a, f = d(p * h), m = d(u * l), y = d(p * l), S = d(h * u);
    return new _w(f, m, S, y);
  }
  add(t) {
    Gt(t);
    const { x: e, y: r, z: o, t: i } = this, { x: a, y: n, z: c, t: p } = t, u = d((r - e) * (n + a)), h = d((r + e) * (n - a)), l = d(h - u);
    if (l === E)
      return this.double();
    const f = d(o * C * p), m = d(i * C * c), y = m + f, S = h + u, P = m - f, B = d(y * l), v = d(S * P), O = d(y * P), k = d(l * S);
    return new _w(B, v, k, O);
  }
  subtract(t) {
    return this.add(t.negate());
  }
  precomputeWindow(t) {
    const e = 1 + 256 / t, r = [];
    let o = this, i = o;
    for (let a = 0; a < e; a++) {
      i = o, r.push(i);
      for (let n = 1; n < 2 ** (t - 1); n++)
        i = i.add(o), r.push(i);
      o = i.double();
    }
    return r;
  }
  wNAF(t, e) {
    !e && this.equals(_w.BASE) && (e = x.BASE);
    const r = e && e._WINDOW_SIZE || 1;
    if (256 % r)
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    let o = e && kt.get(e);
    o || (o = this.precomputeWindow(r), e && r !== 1 && (o = _w.normalizeZ(o), kt.set(e, o)));
    let i = _w.ZERO, a = _w.ZERO;
    const n = 1 + 256 / r, c = 2 ** (r - 1), p = BigInt(2 ** r - 1), u = 2 ** r, h = BigInt(r);
    for (let l = 0; l < n; l++) {
      const f = l * c;
      let m = Number(t & p);
      if (t >>= h, m > c && (m -= u, t += g), m === 0) {
        let y = o[f];
        l % 2 && (y = y.negate()), a = a.add(y);
      } else {
        let y = o[f + Math.abs(m) - 1];
        m < 0 && (y = y.negate()), i = i.add(y);
      }
    }
    return _w.normalizeZ([i, a])[0];
  }
  multiply(t, e) {
    return this.wNAF(yt(t, R.l), e);
  }
  multiplyUnsafe(t) {
    let e = yt(t, R.l, false);
    const r = _w.BASE, o = _w.ZERO;
    if (e === E)
      return o;
    if (this.equals(o) || e === g)
      return this;
    if (this.equals(r))
      return this.wNAF(e);
    let i = o, a = this;
    for (; e > E; )
      e & g && (i = i.add(a)), a = a.double(), e >>= g;
    return i;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(R.h).equals(_w.ZERO);
  }
  isTorsionFree() {
    return this.multiplyUnsafe(R.l).equals(_w.ZERO);
  }
  toAffine(t = vt(this.z)) {
    const { x: e, y: r, z: o } = this, i = d(e * t), a = d(r * t);
    if (d(o * t) !== g)
      throw new Error("invZ was invalid");
    return new x(i, a);
  }
  fromRistrettoBytes() {
    jt();
  }
  toRistrettoBytes() {
    jt();
  }
  fromRistrettoHash() {
    jt();
  }
};
w.BASE = new w(R.Gx, R.Gy, g, d(R.Gx * R.Gy));
w.ZERO = new w(E, g, g, E);
function Gt(s) {
  if (!(s instanceof w))
    throw new TypeError("ExtendedPoint expected");
}
function Ct(s) {
  if (!(s instanceof _))
    throw new TypeError("RistrettoPoint expected");
}
function jt() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var _ = class __ {
  constructor(t) {
    this.ep = t;
  }
  static calcElligatorRistrettoMap(t) {
    const { d: e } = R, r = d(rt * t * t), o = d((r + g) * Fe);
    let i = BigInt(-1);
    const a = d((i - e * r) * d(r + e));
    let { isValid: n, value: c } = Mt(o, a), p = d(c * t);
    V(p) || (p = d(-p)), n || (c = p), n || (i = r);
    const u = d(i * (r - g) * Te - a), h = c * c, l = d((c + c) * a), f = d(u * Oe), m = d(g - h), y = d(g + h);
    return new w(d(l * y), d(m * f), d(f * y), d(l * m));
  }
  static hashToCurve(t) {
    t = G(t, 64);
    const e = Pt(t.slice(0, 32)), r = this.calcElligatorRistrettoMap(e), o = Pt(t.slice(32, 64)), i = this.calcElligatorRistrettoMap(o);
    return new __(r.add(i));
  }
  static fromHex(t) {
    t = G(t, 32);
    const { a: e, d: r } = R, o = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", i = Pt(t);
    if (!Le(at(i), t) || V(i))
      throw new Error(o);
    const a = d(i * i), n = d(g + e * a), c = d(g - e * a), p = d(n * n), u = d(c * c), h = d(e * r * p - u), { isValid: l, value: f } = Jt(d(h * u)), m = d(f * c), y = d(f * m * h);
    let S = d((i + i) * m);
    V(S) && (S = d(-S));
    const P = d(n * y), B = d(S * P);
    if (!l || V(B) || P === E)
      throw new Error(o);
    return new __(new w(S, P, g, B));
  }
  toRawBytes() {
    let { x: t, y: e, z: r, t: o } = this.ep;
    const i = d(d(r + e) * d(r - e)), a = d(t * e), { value: n } = Jt(d(i * a ** C)), c = d(n * i), p = d(n * a), u = d(c * p * o);
    let h;
    if (V(o * u)) {
      let f = d(e * rt), m = d(t * rt);
      t = f, e = m, h = d(c * ke);
    } else
      h = p;
    V(t * u) && (e = d(-e));
    let l = d((r - e) * h);
    return V(l) && (l = d(-l)), at(l);
  }
  toHex() {
    return nt(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(t) {
    Ct(t);
    const e = this.ep, r = t.ep, o = d(e.x * r.y) === d(e.y * r.x), i = d(e.y * r.y) === d(e.x * r.x);
    return o || i;
  }
  add(t) {
    return Ct(t), new __(this.ep.add(t.ep));
  }
  subtract(t) {
    return Ct(t), new __(this.ep.subtract(t.ep));
  }
  multiply(t) {
    return new __(this.ep.multiply(t));
  }
  multiplyUnsafe(t) {
    return new __(this.ep.multiplyUnsafe(t));
  }
};
_.BASE = new _(w.BASE);
_.ZERO = new _(w.ZERO);
var kt = /* @__PURE__ */ new WeakMap();
var x = class _x {
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  _setWindowSize(t) {
    this._WINDOW_SIZE = t, kt.delete(this);
  }
  static fromHex(t, e = true) {
    const { d: r, P: o } = R;
    t = G(t, 32);
    const i = t.slice();
    i[31] = t[31] & -129;
    const a = X(i);
    if (e && a >= o)
      throw new Error("Expected 0 < hex < P");
    if (!e && a >= oe)
      throw new Error("Expected 0 < hex < 2**256");
    const n = d(a * a), c = d(n - g), p = d(r * n + g);
    let { isValid: u, value: h } = Mt(c, p);
    if (!u)
      throw new Error("Point.fromHex: invalid y coordinate");
    const l = (h & g) === g;
    return (t[31] & 128) !== 0 !== l && (h = d(-h)), new _x(h, a);
  }
  static async fromPrivateKey(t) {
    return (await St(t)).point;
  }
  toRawBytes() {
    const t = at(this.y);
    return t[31] |= this.x & g ? 128 : 0, t;
  }
  toHex() {
    return nt(this.toRawBytes());
  }
  toX25519() {
    const { y: t } = this, e = d((g + t) * vt(g - t));
    return at(e);
  }
  isTorsionFree() {
    return w.fromAffine(this).isTorsionFree();
  }
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  negate() {
    return new _x(d(-this.x), this.y);
  }
  add(t) {
    return w.fromAffine(this).add(w.fromAffine(t)).toAffine();
  }
  subtract(t) {
    return this.add(t.negate());
  }
  multiply(t) {
    return w.fromAffine(this).multiply(t, this).toAffine();
  }
};
x.BASE = new x(R.Gx, R.Gy);
x.ZERO = new x(E, g);
var It = class _It {
  constructor(t, e) {
    this.r = t, this.s = e, this.assertValidity();
  }
  static fromHex(t) {
    const e = G(t, 64), r = x.fromHex(e.slice(0, 32), false), o = X(e.slice(32, 64));
    return new _It(r, o);
  }
  assertValidity() {
    const { r: t, s: e } = this;
    if (!(t instanceof x))
      throw new Error("Expected Point instance");
    return yt(e, R.l, false), this;
  }
  toRawBytes() {
    const t = new Uint8Array(64);
    return t.set(this.r.toRawBytes()), t.set(at(this.s), 32), t;
  }
  toHex() {
    return nt(this.toRawBytes());
  }
};
function Ie(...s) {
  if (!s.every((r) => r instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (s.length === 1)
    return s[0];
  const t = s.reduce((r, o) => r + o.length, 0), e = new Uint8Array(t);
  for (let r = 0, o = 0; r < s.length; r++) {
    const i = s[r];
    e.set(i, o), o += i.length;
  }
  return e;
}
var Me = Array.from({ length: 256 }, (s, t) => t.toString(16).padStart(2, "0"));
function nt(s) {
  if (!(s instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < s.length; e++)
    t += Me[s[e]];
  return t;
}
function ie(s) {
  if (typeof s != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof s);
  if (s.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(s.length / 2);
  for (let e = 0; e < t.length; e++) {
    const r = e * 2, o = s.slice(r, r + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    t[e] = i;
  }
  return t;
}
function ae(s) {
  const e = s.toString(16).padStart(64, "0");
  return ie(e);
}
function at(s) {
  return ae(s).reverse();
}
function V(s) {
  return (d(s) & g) === g;
}
function X(s) {
  if (!(s instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + nt(Uint8Array.from(s).reverse()));
}
function Pt(s) {
  return d(X(s) & C ** re - g);
}
function d(s, t = R.P) {
  const e = s % t;
  return e >= E ? e : t + e;
}
function vt(s, t = R.P) {
  if (s === E || t <= E)
    throw new Error(`invert: expected positive integers, got n=${s} mod=${t}`);
  let e = d(s, t), r = t, o = E, i = g;
  for (; e !== E; ) {
    const n = r / e, c = r % e, p = o - i * n;
    r = e, e = c, o = i, i = p;
  }
  if (r !== g)
    throw new Error("invert: does not exist");
  return d(o, t);
}
function $e(s, t = R.P) {
  const e = new Array(s.length), r = s.reduce((i, a, n) => a === E ? i : (e[n] = i, d(i * a, t)), g), o = vt(r, t);
  return s.reduceRight((i, a, n) => a === E ? i : (e[n] = d(i * e[n], t), d(i * a, t)), o), e;
}
function F(s, t) {
  const { P: e } = R;
  let r = s;
  for (; t-- > E; )
    r *= r, r %= e;
  return r;
}
function De(s) {
  const { P: t } = R, e = BigInt(5), r = BigInt(10), o = BigInt(20), i = BigInt(40), a = BigInt(80), c = s * s % t * s % t, p = F(c, C) * c % t, u = F(p, g) * s % t, h = F(u, e) * u % t, l = F(h, r) * h % t, f = F(l, o) * l % t, m = F(f, i) * f % t, y = F(m, a) * m % t, S = F(y, a) * m % t, P = F(S, r) * h % t;
  return { pow_p_5_8: F(P, C) * s % t, b2: c };
}
function Mt(s, t) {
  const e = d(t * t * t), r = d(e * e * t), o = De(s * r).pow_p_5_8;
  let i = d(s * e * o);
  const a = d(t * i * i), n = i, c = d(i * rt), p = a === s, u = a === d(-s), h = a === d(-s * rt);
  return p && (i = n), (u || h) && (i = c), V(i) && (i = d(-i)), { isValid: p || u, value: i };
}
function Jt(s) {
  return Mt(g, s);
}
async function qt(...s) {
  const t = await ct.sha512(Ie(...s)), e = X(t);
  return d(e, R.l);
}
function Le(s, t) {
  if (s.length !== t.length)
    return false;
  for (let e = 0; e < s.length; e++)
    if (s[e] !== t[e])
      return false;
  return true;
}
function G(s, t) {
  const e = s instanceof Uint8Array ? Uint8Array.from(s) : ie(s);
  if (typeof t == "number" && e.length !== t)
    throw new Error(`Expected ${t} bytes`);
  return e;
}
function yt(s, t, e = true) {
  if (!t)
    throw new TypeError("Specify max value");
  if (typeof s == "number" && Number.isSafeInteger(s) && (s = BigInt(s)), typeof s == "bigint" && s < t) {
    if (e) {
      if (E < s)
        return s;
    } else if (E <= s)
      return s;
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function We(s) {
  return s[0] &= 248, s[31] &= 127, s[31] |= 64, s;
}
async function St(s) {
  if (s = typeof s == "bigint" || typeof s == "number" ? ae(yt(s, oe)) : G(s), s.length !== 32)
    throw new Error("Expected 32 bytes");
  const t = await ct.sha512(s), e = We(t.slice(0, 32)), r = t.slice(32, 64), o = d(X(e), R.l), i = x.BASE.multiply(o), a = i.toRawBytes();
  return { head: e, prefix: r, scalar: o, point: i, pointBytes: a };
}
async function ne(s) {
  return (await St(s)).pointBytes;
}
async function ze(s, t) {
  s = G(s);
  const { prefix: e, scalar: r, pointBytes: o } = await St(t), i = await qt(e, s), a = x.BASE.multiply(i), n = await qt(a.toRawBytes(), o, s), c = d(i + n * r, R.l);
  return new It(a, c).toRawBytes();
}
x.BASE._setWindowSize(8);
var W = {
  node: Be,
  web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
};
var ct = {
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  bytesToHex: nt,
  getExtendedPublicKey: St,
  mod: d,
  invert: vt,
  hashToPrivateScalar: (s) => {
    if (s = G(s), s.length < 40 || s.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    const t = d(X(s), R.l);
    if (t === E || t === g)
      throw new Error("Invalid private key");
    return t;
  },
  randomBytes: (s = 32) => {
    if (W.web)
      return W.web.getRandomValues(new Uint8Array(s));
    if (W.node) {
      const { randomBytes: t } = W.node;
      return new Uint8Array(t(s).buffer);
    } else
      throw new Error("The environment doesn't have randomBytes function");
  },
  randomPrivateKey: () => ct.randomBytes(32),
  sha512: async (s) => {
    if (W.web) {
      const t = await W.web.subtle.digest("SHA-512", s.buffer);
      return new Uint8Array(t);
    } else {
      if (W.node)
        return Uint8Array.from(W.node.createHash("sha512").update(s).digest());
      throw new Error("The environment doesn't have sha512 function");
    }
  },
  precompute(s = 8, t = x.BASE) {
    const e = t.equals(x.BASE) ? t : new x(t.x, t.y);
    return e._setWindowSize(s), e.multiply(C), e;
  }
};
function He(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var Ve = function(s, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  var e = typeof t.cycles == "boolean" ? t.cycles : false, r = t.cmp && /* @__PURE__ */ function(i) {
    return function(a) {
      return function(n, c) {
        var p = { key: n, value: a[n] }, u = { key: c, value: a[c] };
        return i(p, u);
      };
    };
  }(t.cmp), o = [];
  return function i(a) {
    if (a && a.toJSON && typeof a.toJSON == "function" && (a = a.toJSON()), a !== void 0) {
      if (typeof a == "number") return isFinite(a) ? "" + a : "null";
      if (typeof a != "object") return JSON.stringify(a);
      var n, c;
      if (Array.isArray(a)) {
        for (c = "[", n = 0; n < a.length; n++)
          n && (c += ","), c += i(a[n]) || "null";
        return c + "]";
      }
      if (a === null) return "null";
      if (o.indexOf(a) !== -1) {
        if (e) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var p = o.push(a) - 1, u = Object.keys(a).sort(r && r(a));
      for (c = "", n = 0; n < u.length; n++) {
        var h = u[n], l = i(a[h]);
        l && (c && (c += ","), c += JSON.stringify(h) + ":" + l);
      }
      return o.splice(p, 1), "{" + c + "}";
    }
  }(s);
};
var Ke = He(Ve);
var Y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var tt = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (ht = 0; ht < Y.length; ht++)
  tt[Y.charCodeAt(ht)] = ht;
var ht;
var bt = function(s) {
  var t = new Uint8Array(s), e, r = t.length, o = "";
  for (e = 0; e < r; e += 3)
    o += Y[t[e] >> 2], o += Y[(t[e] & 3) << 4 | t[e + 1] >> 4], o += Y[(t[e + 1] & 15) << 2 | t[e + 2] >> 6], o += Y[t[e + 2] & 63];
  return r % 3 === 2 ? o = o.substring(0, o.length - 1) + "=" : r % 3 === 1 && (o = o.substring(0, o.length - 2) + "=="), o;
};
var ce = function(s) {
  var t = s.length * 0.75, e = s.length, r, o = 0, i, a, n, c;
  s[s.length - 1] === "=" && (t--, s[s.length - 2] === "=" && t--);
  var p = new ArrayBuffer(t), u = new Uint8Array(p);
  for (r = 0; r < e; r += 4)
    i = tt[s.charCodeAt(r)], a = tt[s.charCodeAt(r + 1)], n = tt[s.charCodeAt(r + 2)], c = tt[s.charCodeAt(r + 3)], u[o++] = i << 2 | a >> 4, u[o++] = (a & 15) << 4 | n >> 2, u[o++] = (n & 3) << 6 | c & 63;
  return p;
};
var Ut = (s) => new DataView(s.buffer, s.byteOffset, s.byteLength);
var Ge = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Ge)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (s, t) => t.toString(16).padStart(2, "0"));
(() => {
  const s = typeof module < "u" && typeof module.require == "function" && module.require.bind(module);
  try {
    if (s) {
      const { setImmediate: t } = s("timers");
      return () => new Promise((e) => t(e));
    }
  } catch {
  }
  return () => new Promise((t) => setTimeout(t, 0));
})();
function Je(s) {
  if (typeof s != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof s}`);
  return new TextEncoder().encode(s);
}
function de(s) {
  if (typeof s == "string" && (s = Je(s)), !(s instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof s})`);
  return s;
}
var qe = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function $t(s) {
  const t = (r) => s().update(de(r)).digest(), e = s();
  return t.outputLen = e.outputLen, t.blockLen = e.blockLen, t.create = () => s(), t.init = t.create, t;
}
function Ze(s, t, e, r) {
  if (typeof s.setBigUint64 == "function")
    return s.setBigUint64(t, e, r);
  const o = BigInt(32), i = BigInt(4294967295), a = Number(e >> o & i), n = Number(e & i), c = r ? 4 : 0, p = r ? 0 : 4;
  s.setUint32(t + c, a, r), s.setUint32(t + p, n, r);
}
var Ye = class extends qe {
  constructor(t, e, r, o) {
    super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = Ut(this.buffer);
  }
  update(t) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    const { view: e, buffer: r, blockLen: o, finished: i } = this;
    if (i)
      throw new Error("digest() was already called");
    t = de(t);
    const a = t.length;
    for (let n = 0; n < a; ) {
      const c = Math.min(o - this.pos, a - n);
      if (c === o) {
        const p = Ut(t);
        for (; o <= a - n; n += o)
          this.process(p, n);
        continue;
      }
      r.set(t.subarray(n, n + c), this.pos), this.pos += c, n += c, this.pos === o && (this.process(e, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    if (!(t instanceof Uint8Array) || t.length < this.outputLen)
      throw new Error("_Sha2: Invalid output buffer");
    if (this.finished)
      throw new Error("digest() was already called");
    this.finished = true;
    const { buffer: e, view: r, blockLen: o, isLE: i } = this;
    let { pos: a } = this;
    e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o - a && (this.process(r, 0), a = 0);
    for (let c = a; c < o; c++)
      e[c] = 0;
    Ze(r, o - 8, BigInt(this.length * 8), i), this.process(r, 0);
    const n = Ut(t);
    this.get().forEach((c, p) => n.setUint32(4 * p, c, i));
  }
  digest() {
    const { buffer: t, outputLen: e } = this;
    this.digestInto(t);
    const r = t.slice(0, e);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: e, buffer: r, length: o, finished: i, destroyed: a, pos: n } = this;
    return t.length = o, t.pos = n, t.finished = i, t.destroyed = a, o % e && t.buffer.set(r), t;
  }
};
var ut = BigInt(2 ** 32 - 1);
var Zt = BigInt(32);
function Xe(s, t = false) {
  return t ? { h: Number(s & ut), l: Number(s >> Zt & ut) } : { h: Number(s >> Zt & ut) | 0, l: Number(s & ut) | 0 };
}
function Qe(s, t = false) {
  let e = new Uint32Array(s.length), r = new Uint32Array(s.length);
  for (let o = 0; o < s.length; o++) {
    const { h: i, l: a } = Xe(s[o], t);
    [e[o], r[o]] = [i, a];
  }
  return [e, r];
}
var Yt = (s, t, e) => s >>> e;
var Xt = (s, t, e) => s << 32 - e | t >>> e;
var q = (s, t, e) => s >>> e | t << 32 - e;
var Z = (s, t, e) => s << 32 - e | t >>> e;
var lt = (s, t, e) => s << 64 - e | t >>> e - 32;
var mt = (s, t, e) => s >>> e - 32 | t << 64 - e;
function $(s, t, e, r) {
  const o = (t >>> 0) + (r >>> 0);
  return { h: s + e + (o / 2 ** 32 | 0) | 0, l: o | 0 };
}
var ts = (s, t, e) => (s >>> 0) + (t >>> 0) + (e >>> 0);
var es = (s, t, e, r) => t + e + r + (s / 2 ** 32 | 0) | 0;
var ss = (s, t, e, r) => (s >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0);
var rs = (s, t, e, r, o) => t + e + r + o + (s / 2 ** 32 | 0) | 0;
var os = (s, t, e, r, o) => (s >>> 0) + (t >>> 0) + (e >>> 0) + (r >>> 0) + (o >>> 0);
var is = (s, t, e, r, o, i) => t + e + r + o + i + (s / 2 ** 32 | 0) | 0;
var [as, ns] = Qe([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((s) => BigInt(s)));
var z = new Uint32Array(80);
var H = new Uint32Array(80);
var Dt = class extends Ye {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: e, Bh: r, Bl: o, Ch: i, Cl: a, Dh: n, Dl: c, Eh: p, El: u, Fh: h, Fl: l, Gh: f, Gl: m, Hh: y, Hl: S } = this;
    return [t, e, r, o, i, a, n, c, p, u, h, l, f, m, y, S];
  }
  // prettier-ignore
  set(t, e, r, o, i, a, n, c, p, u, h, l, f, m, y, S) {
    this.Ah = t | 0, this.Al = e | 0, this.Bh = r | 0, this.Bl = o | 0, this.Ch = i | 0, this.Cl = a | 0, this.Dh = n | 0, this.Dl = c | 0, this.Eh = p | 0, this.El = u | 0, this.Fh = h | 0, this.Fl = l | 0, this.Gh = f | 0, this.Gl = m | 0, this.Hh = y | 0, this.Hl = S | 0;
  }
  process(t, e) {
    for (let v = 0; v < 16; v++, e += 4)
      z[v] = t.getUint32(e), H[v] = t.getUint32(e += 4);
    for (let v = 16; v < 80; v++) {
      const O = z[v - 15] | 0, k = H[v - 15] | 0, Rt = q(O, k, 1) ^ q(O, k, 8) ^ Yt(O, k, 7), At = Z(O, k, 1) ^ Z(O, k, 8) ^ Xt(O, k, 7), I = z[v - 2] | 0, M = H[v - 2] | 0, dt = q(I, M, 19) ^ lt(I, M, 61) ^ Yt(I, M, 6), xt = Z(I, M, 19) ^ mt(I, M, 61) ^ Xt(I, M, 6), pt = ss(At, xt, H[v - 7], H[v - 16]), Et = rs(pt, Rt, dt, z[v - 7], z[v - 16]);
      z[v] = Et | 0, H[v] = pt | 0;
    }
    let { Ah: r, Al: o, Bh: i, Bl: a, Ch: n, Cl: c, Dh: p, Dl: u, Eh: h, El: l, Fh: f, Fl: m, Gh: y, Gl: S, Hh: P, Hl: B } = this;
    for (let v = 0; v < 80; v++) {
      const O = q(h, l, 14) ^ q(h, l, 18) ^ lt(h, l, 41), k = Z(h, l, 14) ^ Z(h, l, 18) ^ mt(h, l, 41), Rt = h & f ^ ~h & y, At = l & m ^ ~l & S, I = os(B, k, At, ns[v], H[v]), M = is(I, P, O, Rt, as[v], z[v]), dt = I | 0, xt = q(r, o, 28) ^ lt(r, o, 34) ^ lt(r, o, 39), pt = Z(r, o, 28) ^ mt(r, o, 34) ^ mt(r, o, 39), Et = r & i ^ r & n ^ i & n, je = o & a ^ o & c ^ a & c;
      P = y | 0, B = S | 0, y = f | 0, S = m | 0, f = h | 0, m = l | 0, { h, l } = $(p | 0, u | 0, M | 0, dt | 0), p = n | 0, u = c | 0, n = i | 0, c = a | 0, i = r | 0, a = o | 0;
      const Vt = ts(dt, pt, je);
      r = es(Vt, M, xt, Et), o = Vt | 0;
    }
    ({ h: r, l: o } = $(this.Ah | 0, this.Al | 0, r | 0, o | 0)), { h: i, l: a } = $(this.Bh | 0, this.Bl | 0, i | 0, a | 0), { h: n, l: c } = $(this.Ch | 0, this.Cl | 0, n | 0, c | 0), { h: p, l: u } = $(this.Dh | 0, this.Dl | 0, p | 0, u | 0), { h, l } = $(this.Eh | 0, this.El | 0, h | 0, l | 0), { h: f, l: m } = $(this.Fh | 0, this.Fl | 0, f | 0, m | 0), { h: y, l: S } = $(this.Gh | 0, this.Gl | 0, y | 0, S | 0), { h: P, l: B } = $(this.Hh | 0, this.Hl | 0, P | 0, B | 0), this.set(r, o, i, a, n, c, p, u, h, l, f, m, y, S, P, B);
  }
  roundClean() {
    z.fill(0), H.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var cs = class extends Dt {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
var ds = class extends Dt {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
var ps = $t(() => new Dt());
$t(() => new cs());
$t(() => new ds());
var pe = ((s) => (s.ATOMIC_URL = "https://atomicdata.dev/datatypes/atomicURL", s.BOOLEAN = "https://atomicdata.dev/datatypes/boolean", s.DATE = "https://atomicdata.dev/datatypes/date", s.FLOAT = "https://atomicdata.dev/datatypes/float", s.INTEGER = "https://atomicdata.dev/datatypes/integer", s.MARKDOWN = "https://atomicdata.dev/datatypes/markdown", s.RESOURCEARRAY = "https://atomicdata.dev/datatypes/resourceArray", s.SLUG = "https://atomicdata.dev/datatypes/slug", s.STRING = "https://atomicdata.dev/datatypes/string", s.TIMESTAMP = "https://atomicdata.dev/datatypes/timestamp", s.UNKNOWN = "unknown-datatype", s))(pe || {});
var hs = new Set(Object.values(pe));
var us = (s) => hs.has(s) ? s : "unknown-datatype";
var ls = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
var ms = /^\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/;
var fs = (s, t) => {
  let e = null;
  if (s === void 0)
    throw new Error(`Value is undefined, expected ${t}`);
  switch (t) {
    case "https://atomicdata.dev/datatypes/string": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      break;
    }
    case "https://atomicdata.dev/datatypes/markdown": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      break;
    }
    case "https://atomicdata.dev/datatypes/slug": {
      if (!Q(s)) {
        e = "Not a slug, not even a string";
        break;
      }
      s.match(ls) === null && (e = "Not a valid slug. Only lowercase letters and numbers with dashes `-` between them");
      break;
    }
    case "https://atomicdata.dev/datatypes/atomicURL": {
      if (!Q(s)) {
        e = "Not a string. Should be a URL";
        break;
      }
      N.tryValidSubject(s);
      break;
    }
    case "https://atomicdata.dev/datatypes/resourceArray": {
      if (!Lt(s)) {
        e = "Not an array";
        break;
      }
      s.map((r, o) => {
        try {
          N.tryValidSubject(r);
        } catch {
          const a = new Error("Invalid URL");
          throw a.index = o, a;
        }
      });
      break;
    }
    case "https://atomicdata.dev/datatypes/integer": {
      if (!he(s)) {
        e = "Not a number";
        break;
      }
      s % 1 !== 0 && (e = "Not an integer");
      break;
    }
    case "https://atomicdata.dev/datatypes/date": {
      if (!Q(s)) {
        e = "Not a string";
        break;
      }
      s.match(ms) === null && (e = "Not a date string: YYYY-MM-DD");
      break;
    }
  }
  if (e !== null)
    throw new Error(e);
};
function Lt(s) {
  return Object.prototype.toString.call(s) === "[object Array]";
}
function Q(s) {
  return typeof s == "string";
}
function he(s) {
  return typeof s == "number";
}
var nr = {
  "https://atomicdata.dev/datatypes/string": "String",
  "https://atomicdata.dev/datatypes/slug": "Slug",
  "https://atomicdata.dev/datatypes/markdown": "Markdown",
  "https://atomicdata.dev/datatypes/integer": "Integer",
  "https://atomicdata.dev/datatypes/float": "Float",
  "https://atomicdata.dev/datatypes/boolean": "Boolean",
  "https://atomicdata.dev/datatypes/date": "Date",
  "https://atomicdata.dev/datatypes/timestamp": "Timestamp",
  "https://atomicdata.dev/datatypes/atomicURL": "Resource",
  "https://atomicdata.dev/datatypes/resourceArray": "ResourceArray",
  "unknown-datatype": "Unknown"
};
var et = ((s) => (s.Unauthorized = "Unauthorized", s.NotFound = "NotFound", s.Server = "Server", s.Client = "Client", s))(et || {});
function gs(s) {
  if (s instanceof j) {
    if (s.type === "Unauthorized")
      return true;
    if (s.message.includes("Unauthorized"))
      return true;
  }
  return false;
}
function cr(s) {
  return s instanceof j;
}
var j = class _j extends Error {
  /** Creates an AtomicError. The message can be either a plain string, or a JSON-AD Error Resource */
  constructor(t, e = "Client") {
    super(t), Object.setPrototypeOf(this, _j.prototype), this.type = e, this.message = t;
    try {
      const o = JSON.parse(t)[A.properties.description];
      o && (this.message = o);
    } catch {
    }
    this.message || (this.message = this.createMessage());
  }
  static fromResource(t) {
    return new _j(t.get(A.properties.description).toString());
  }
  createMessage() {
    switch (this.type) {
      case "Unauthorized":
        return "You don't have the rights to do this.";
      case "NotFound":
        return "404 Not found.";
      case "Server":
        return "500 Unknown server error.";
      default:
        return "Unknown error.";
    }
  }
};
var ue = class {
  constructor() {
    this.subscriptions = /* @__PURE__ */ new Map();
  }
  register(t, e) {
    const r = this.subscriptions.get(t) ?? /* @__PURE__ */ new Set();
    return r.add(e), this.subscriptions.set(t, r), () => {
      r.delete(e);
    };
  }
  async emit(t, ...e) {
    if (!this.subscriptions.has(t)) return;
    const r = this.subscriptions.get(t), o = async (i) => i(...e);
    r && await Promise.allSettled([...r].map((i) => o(i)));
  }
  hasSubscriptions(t) {
    return this.subscriptions.has(t);
  }
};
var Wt = class _Wt {
  constructor(t, e, r, o = false) {
    this.__internalObject = this, this.pages = /* @__PURE__ */ new Map(), this._totalMembers = 0, this.store = t, this.server = e, this.params = r, o || (this._waitForReady = this.fetchPage(0)), this.clearPages = this.clearPages.bind(this);
  }
  get property() {
    return this.params.property;
  }
  get value() {
    return this.params.value;
  }
  get sortBy() {
    return this.params.sort_by;
  }
  get sortDesc() {
    return !!this.params.sort_desc;
  }
  get pageSize() {
    return parseInt(this.params.page_size, 10);
  }
  get totalMembers() {
    return this._totalMembers;
  }
  get totalPages() {
    return Math.ceil(this.totalMembers / this.pageSize);
  }
  waitForReady() {
    return this._waitForReady;
  }
  async getMemberWithIndex(t) {
    if (t >= this.totalMembers)
      throw new Error("Index out of bounds");
    const e = Math.floor(t / this.pageSize);
    return this.pages.has(e) || (this._waitForReady = this.fetchPage(e), await this._waitForReady), this.pages.get(e).getSubjects(Tt.properties.members)[t % this.pageSize];
  }
  clearPages() {
    this.pages = /* @__PURE__ */ new Map();
  }
  async refresh() {
    return this.clearPages(), this._waitForReady = this.fetchPage(0), this._waitForReady;
  }
  clone() {
    const t = new _Wt(this.store, this.server, this.params);
    return t._totalMembers = this._totalMembers, t._waitForReady = this._waitForReady, t.pages = this.pages, t;
  }
  async *[Symbol.asyncIterator]() {
    await this.waitForReady();
    for (let t = 0; t < this.totalMembers; t++) {
      const e = await this.getMemberWithIndex(t);
      e !== void 0 && (yield e);
    }
  }
  async getAllMembers() {
    const t = [];
    for await (const e of this)
      t.push(e);
    return t;
  }
  async getMembersOnPage(t) {
    return this.pages.has(t) || await this.fetchPage(t), (this.pages.get(t).props.members ?? []).filter((r) => r !== void 0);
  }
  buildSubject(t) {
    const e = new URL(`${this.server}/query`);
    for (const [r, o] of Object.entries(this.params))
      e.searchParams.set(r, o);
    return e.searchParams.set("current_page", `${t}`), e.toString();
  }
  async fetchPage(t) {
    const e = this.buildSubject(t), r = await this.store.fetchResourceFromServer(e);
    if (!r)
      throw new Error("Invalid collection: resource does not exist");
    if (r.error)
      throw new Error(
        `Invalid collection: resource has error: ${r.error}`
      );
    this.pages.set(t, r);
    const o = r.props.totalMembers;
    if (!he(o))
      throw new Error("Invalid collection: total-members is not a number");
    this._totalMembers = o;
  }
};
function dr(s) {
  return s.__internalObject !== s && console.warn("Attempted to proxy a proxy for a collection"), new Proxy(s.__internalObject, {});
}
var ys = class {
  constructor(t, e) {
    this.params = {
      page_size: "30"
    }, this.store = t, this.server = e ?? new URL(t.getServerUrl()).origin;
  }
  setProperty(t) {
    return this.params.property = t, this;
  }
  setValue(t) {
    return this.params.value = t, this;
  }
  setSortBy(t) {
    return this.params.sort_by = t, this;
  }
  setSortDesc(t) {
    return this.params.sort_desc = t, this;
  }
  setPageSize(t) {
    return this.params.page_size = `${t}`, this;
  }
  build() {
    return new Wt(this.store, this.server, this.params);
  }
  async buildAndFetch() {
    const t = this.build();
    return await t.waitForReady(), t;
  }
};
var bs = {
  agent: "https://atomicdata.dev/classes/Agent",
  chatRoom: "https://atomicdata.dev/classes/ChatRoom",
  collection: "https://atomicdata.dev/classes/Collection",
  commit: "https://atomicdata.dev/classes/Commit",
  class: "https://atomicdata.dev/classes/Class",
  document: "https://atomicdata.dev/classes/Document",
  bookmark: "https://atomicdata.dev/class/Bookmark",
  elements: {
    paragraph: "https://atomicdata.dev/classes/elements/Paragraph"
  },
  error: "https://atomicdata.dev/classes/Error",
  property: "https://atomicdata.dev/classes/Property",
  datatype: "https://atomicdata.dev/classes/Datatype",
  endpoint: "https://atomicdata.dev/classes/Endpoint",
  drive: "https://atomicdata.dev/classes/Drive",
  redirect: "https://atomicdata.dev/classes/Redirect",
  invite: "https://atomicdata.dev/classes/Invite",
  file: "https://atomicdata.dev/classes/File",
  message: "https://atomicdata.dev/classes/Message",
  importer: "https://atomicdata.dev/classes/Importer",
  folder: "https://atomicdata.dev/classes/Folder",
  article: "https://atomicdata.dev/classes/Article",
  displayStyle: "https://atomicdata.dev/class/DisplayStyle",
  displayStyles: {
    grid: "https://atomicdata.dev/display-style/grid",
    list: "https://atomicdata.dev/display-style/list"
  },
  dateFormat: "https://atomicdata.dev/classes/DateFormat",
  numberFormat: "https://atomicdata.dev/classes/NumberFormat",
  constraintProperties: {
    rangeProperty: "https://atomicdata.dev/classes/RangeProperty",
    floatRangeProperty: "https://atomicdata.dev/classes/FloatRangeProperty",
    formattedNumber: "https://atomicdata.dev/classes/FormattedNumber",
    selectProperty: "https://atomicdata.dev/classes/SelectProperty",
    formattedDate: "https://atomicdata.dev/classes/FormattedDate"
  },
  table: "https://atomicdata.dev/classes/Table",
  tag: "https://atomicdata.dev/classes/Tag",
  ontology: "https://atomicdata.dev/class/ontology"
};
var U = {
  /** Collection of all the AtomicData.dev properties */
  allowsOnly: "https://atomicdata.dev/properties/allowsOnly",
  getAll: "https://atomicdata.dev/properties/?page_size=999",
  children: "https://atomicdata.dev/properties/children",
  classType: "https://atomicdata.dev/properties/classtype",
  createdBy: "https://atomicdata.dev/properties/createdBy",
  datatype: "https://atomicdata.dev/properties/datatype",
  description: "https://atomicdata.dev/properties/description",
  drives: "https://atomicdata.dev/properties/drives",
  incomplete: "https://atomicdata.dev/properties/incomplete",
  isA: "https://atomicdata.dev/properties/isA",
  isDynamic: "https://atomicdata.dev/properties/isDynamic",
  name: "https://atomicdata.dev/properties/name",
  parent: "https://atomicdata.dev/properties/parent",
  paymentPointer: "https://atomicdata.dev/properties/paymentPointer",
  read: "https://atomicdata.dev/properties/read",
  recommends: "https://atomicdata.dev/properties/recommends",
  requires: "https://atomicdata.dev/properties/requires",
  shortname: "https://atomicdata.dev/properties/shortname",
  subResources: "https://atomicdata.dev/properties/subresources",
  write: "https://atomicdata.dev/properties/write",
  displayStyle: "https://atomicdata.dev/property/display-style",
  publishedAt: "https://atomicdata.dev/properties/published-at",
  agent: {
    publicKey: "https://atomicdata.dev/properties/publicKey"
  },
  collection: {
    members: "https://atomicdata.dev/properties/collection/members",
    currentPage: "https://atomicdata.dev/properties/collection/currentPage",
    pageSize: "https://atomicdata.dev/properties/collection/pageSize",
    property: "https://atomicdata.dev/properties/collection/property",
    totalMembers: "https://atomicdata.dev/properties/collection/totalMembers",
    totalPages: "https://atomicdata.dev/properties/collection/totalPages",
    value: "https://atomicdata.dev/properties/collection/value"
  },
  commit: {
    subject: "https://atomicdata.dev/properties/subject",
    createdAt: "https://atomicdata.dev/properties/createdAt",
    lastCommit: "https://atomicdata.dev/properties/lastCommit",
    previousCommit: "https://atomicdata.dev/properties/previousCommit",
    signer: "https://atomicdata.dev/properties/signer",
    set: "https://atomicdata.dev/properties/set",
    push: "https://atomicdata.dev/properties/push",
    remove: "https://atomicdata.dev/properties/remove",
    destroy: "https://atomicdata.dev/properties/destroy",
    signature: "https://atomicdata.dev/properties/signature"
  },
  document: {
    elements: "https://atomicdata.dev/properties/documents/elements"
  },
  endpoint: {
    parameters: "https://atomicdata.dev/properties/endpoint/parameters",
    results: "https://atomicdata.dev/properties/endpoint/results"
  },
  search: {
    query: "https://atomicdata.dev/properties/search/query",
    limit: "https://atomicdata.dev/properties/search/limit",
    property: "https://atomicdata.dev/properties/search/property"
  },
  redirect: {
    destination: "https://atomicdata.dev/properties/destination",
    redirectAgent: "https://atomicdata.dev/properties/invite/redirectAgent"
  },
  invite: {
    agent: "https://atomicdata.dev/properties/invite/agent",
    publicKey: "https://atomicdata.dev/properties/invite/publicKey",
    target: "https://atomicdata.dev/properties/invite/target",
    usagesLeft: "https://atomicdata.dev/properties/invite/usagesLeft",
    users: "https://atomicdata.dev/properties/invite/users",
    write: "https://atomicdata.dev/properties/invite/write"
  },
  file: {
    filename: "https://atomicdata.dev/properties/filename",
    filesize: "https://atomicdata.dev/properties/filesize",
    downloadUrl: "https://atomicdata.dev/properties/downloadURL",
    mimetype: "https://atomicdata.dev/properties/mimetype",
    attachments: "https://atomicdata.dev/properties/attachments"
  },
  chatRoom: {
    messages: "https://atomicdata.dev/properties/messages",
    nextPage: "https://atomicdata.dev/properties/nextPage",
    replyTo: "https://atomicdata.dev/properties/replyTo"
  },
  bookmark: {
    url: "https://atomicdata.dev/property/url",
    preview: "https://atomicdata.dev/property/preview",
    imageUrl: "https://atomicdata.dev/properties/imageUrl"
  },
  constraints: {
    max: "https://atomicdata.dev/properties/max",
    min: "https://atomicdata.dev/properties/min",
    maxFloat: "https://atomicdata.dev/properties/maxFloat",
    minFloat: "https://atomicdata.dev/properties/minFloat",
    numberFormatting: "https://atomicdata.dev/properties/numberFormatting",
    decimalPlaces: "https://atomicdata.dev/properties/decimalPlaces",
    dateFormat: "https://atomicdata.dev/properties/dateFormat"
  },
  table: {
    tableColumnWidths: "https://atomicdata.dev/properties/tableColumnWidths"
  },
  ontology: {
    customNodePositioning: "https://atomicdata.dev/properties/custom-node-positioning"
  },
  color: "https://atomicdata.dev/properties/color",
  emoji: "https://atomicdata.dev/properties/emoji",
  classes: "https://atomicdata.dev/properties/classes",
  properties: "https://atomicdata.dev/properties/properties",
  instances: "https://atomicdata.dev/properties/instances"
};
var ws = {
  atomicUrl: "https://atomicdata.dev/datatypes/atomicURL",
  boolean: "https://atomicdata.dev/datatypes/boolean",
  date: "https://atomicdata.dev/datatypes/date",
  float: "https://atomicdata.dev/datatypes/float",
  integer: "https://atomicdata.dev/datatypes/integer",
  markdown: "https://atomicdata.dev/datatypes/markdown",
  resourceArray: "https://atomicdata.dev/datatypes/resourceArray",
  slug: "https://atomicdata.dev/datatypes/slug",
  string: "https://atomicdata.dev/datatypes/string",
  timestamp: "https://atomicdata.dev/datatypes/timestamp"
};
var le = {
  publicAgent: "https://atomicdata.dev/agents/publicAgent",
  displayStyleGrid: "https://atomicdata.dev/agents/publicAgent",
  numberFormats: {
    number: "https://atomicdata.dev/classes/NumberFormat/number",
    percentage: "https://atomicdata.dev/classes/NumberFormat/Percentage",
    currency: "https://atomicdata.dev/ontology/data-browser/number-format/vAikhI3z"
  },
  dateFormats: {
    localNumeric: "https://atomicdata.dev/classes/DateFormat/localNumeric",
    localLong: "https://atomicdata.dev/classes/DateFormat/localLong",
    localRelative: "https://atomicdata.dev/classes/DateFormat/localRelative"
  }
};
var me = {
  import: "/import"
};
var b = {
  properties: U,
  endpoints: me,
  classes: bs,
  datatypes: ws,
  instances: le
};
function _t(s) {
  if (s === void 0)
    throw new Error(`Not an array: ${s}, is ${typeof s}`);
  if (s.constructor === Array)
    return s;
  throw new Error(`Not an array: ${s}, is a ${typeof s}`);
}
function pr(s) {
  if (typeof s != "boolean")
    throw new Error(`Not a boolean: ${s}, is a ${typeof s}`);
  return s;
}
function hr(s) {
  if (typeof s == "number") {
    const t = /* @__PURE__ */ new Date(0);
    return t.setUTCMilliseconds(s), t;
  }
  if (typeof s == "string")
    return new Date(s.toString());
  throw new Error(`Cannot be converted into Date: ${s}, is a ${typeof s}`);
}
function ur(s) {
  if (typeof s != "number")
    throw new Error(`Not a number: ${s}, is a ${typeof s}`);
  return s;
}
function lr(s) {
  return (s == null ? void 0 : s.toString()) ?? "undefined";
}
function mr(s) {
  if (typeof s == "string")
    return s;
  if (s instanceof Date)
    throw new Error(`Not a resource: ${s}, is a Date`);
  if ((s == null ? void 0 : s.constructor) === Array)
    throw new Error(`Not a resource: ${s}, is an Array`);
  if (typeof s == "object") {
    const t = new J(), [e] = t.parseObject(s, "nested-resource");
    return e;
  }
  throw typeof s != "object" ? new Error(`Not a resource: ${s}, is a ${typeof s}`) : new Error(`Not a resource: ${s}, is a ${typeof s}`);
}
var K = "unknown-subject";
var vs = ((s) => (s.LocalChange = "local-change", s))(vs || {});
var L = class _L {
  constructor(t, e) {
    if (this.loading = false, this.appliedCommitSignatures = /* @__PURE__ */ new Set(), this.__internalObject = this, this.propvals = /* @__PURE__ */ new Map(), this.hasQueue = false, this.eventManager = new ue(), typeof t != "string")
      throw new Error(
        "Invalid subject given to resource, must be a string, found " + typeof t
      );
    this.new = !!e, this._subject = t, this.commitBuilder = new ot(t);
  }
  /** The subject URL of the resource */
  get subject() {
    return this._subject;
  }
  /** A human readable title for the resource, returns first of eighter: name, shortname, filename or subject */
  get title() {
    return this.get(A.properties.name) ?? this.get(A.properties.shortname) ?? this.get(wt.properties.filename) ?? this.subject;
  }
  /**
   * Dynamic prop accessor, only works for known properties registered via an ontology.
   * @example const description = resource.props.description
   */
  get props() {
    const t = {};
    for (const e of this.propvals.keys()) {
      const r = Ue(e);
      r && (t[r] = this.get(e));
    }
    return t;
  }
  get store() {
    if (!this._store)
      throw console.error(`Resource ${this.title} has no store`), new Error("Resource has no store");
    return this._store;
  }
  on(t, e) {
    return this.eventManager.register(t, e);
  }
  /** @internal */
  setStore(t) {
    this._store = t;
  }
  /** Checks if the content of two Resource instances is equal */
  equals(t) {
    return this === t.__internalObject ? true : !(this.subject !== t.subject || this.new !== t.new || this.error !== t.error || this.loading !== t.loading || JSON.stringify(Array.from(this.propvals.entries())) !== JSON.stringify(Array.from(t.propvals.entries())) || JSON.stringify(Array.from(this.commitBuilder.set.entries())) !== JSON.stringify(Array.from(t.commitBuilder.set.entries())));
  }
  /** Checks if the agent has write rights by traversing the graph. Recursive function. */
  async canWrite(t, e) {
    const r = this.get(U.write);
    if (!t)
      return [false, "No agent given"];
    if (r && _t(r).includes(t))
      return [true, void 0];
    if (r && _t(r).includes(le.publicAgent))
      return [true, void 0];
    const o = this.get(U.parent);
    return o ? o === t ? [true, void 0] : e === o ? (console.warn("Circular parent", e), [true, `Circular parent in ${this.subject}`]) : await (await this.store.getResource(o)).canWrite(t, this.subject) : [false, `No write right or parent in ${this.subject}`];
  }
  /**
   * Creates a clone of the Resource, which makes sure the reference is
   * different from the previous one. This can be useful when doing reference compares.
   */
  clone() {
    const t = new _L(this.subject);
    return t.propvals = structuredClone(this.propvals), t.loading = this.loading, t.new = this.new, t.error = structuredClone(this.error), t.commitError = this.commitError, t.commitBuilder = this.commitBuilder.clone(), t.appliedCommitSignatures = this.appliedCommitSignatures, t;
  }
  /** Checks if the resource is both loaded and free from errors */
  isReady() {
    return !this.loading && this.error === void 0;
  }
  /** Get a Value by its property
   * @param propUrl The subject of the property
   * @example
   * import { core } from '@tomic/lib'
   * const description = resource.get(core.properties.description)
   * const publishedAt = resource.get('https://my-atomicserver.dev/properties/published-at')
   */
  get(t) {
    return this.propvals.get(t);
  }
  /**
   * Get a Value by its property, returns as Array with subjects instead of the
   * full resource or throws error. Returns empty array if there is no value
   */
  getSubjects(t) {
    return this.getArray(t).map((e) => typeof e == "string" ? e : e["@id"]);
  }
  /**
   * Get a Value by its property, returns as Array or throws error. Returns
   * empty array if there is no value
   */
  getArray(t) {
    const e = this.propvals.get(t) ?? [];
    return _t(e);
  }
  /** Returns a list of classes of this resource */
  getClasses() {
    return this.getSubjects(A.properties.isA);
  }
  /** Checks if the resource is all of the given classes */
  hasClasses(...t) {
    return t.every(
      (e) => this.getClasses().includes(e)
    );
  }
  matchClass(t, e) {
    for (const [r, o] of Object.entries(t))
      if (this.hasClasses(r))
        return o;
    return e;
  }
  /** Remove the given classes from the resource */
  removeClasses(...t) {
    this.set(
      A.properties.isA,
      this.getClasses().filter(
        (e) => !t.includes(e)
      ),
      false
    );
  }
  /** Adds the given classes to the resource */
  addClasses(...t) {
    const e = /* @__PURE__ */ new Set([...this.getClasses(), ...t]);
    return this.set(
      A.properties.isA,
      Array.from(e)
    );
  }
  /** Returns true if the resource has changes in it's commit builder that are not yet saved to the server. */
  hasUnsavedChanges() {
    return this.commitBuilder.hasUnsavedChanges();
  }
  getCommitsCollectionSubject() {
    const t = new URL(this.subject);
    return t.pathname = "/commits", t.searchParams.append("property", b.properties.commit.subject), t.searchParams.append("value", this.subject), t.searchParams.append("sort_by", b.properties.commit.createdAt), t.searchParams.append("include_nested", "true"), t.searchParams.append("page_size", "9999"), t.toString();
  }
  /** Returns a Collection with all children of this resource
   * @param pageSize The amount of children per page (default: 100)
   */
  async getChildrenCollection(t = 100) {
    return await new ys(this.store).setPageSize(t).setProperty(A.properties.parent).setValue(this.subject).buildAndFetch();
  }
  /** builds all versions using the Commits */
  async getHistory(t) {
    const r = (await this.store.fetchResourceFromServer(
      this.getCommitsCollectionSubject()
    )).get(
      U.collection.members
    ), o = [];
    let i = new _L(this.subject);
    for (let a = 0; a < r.length; a++) {
      const n = await this.store.getResource(r[a]), c = xs(n), p = be(
        i.clone(),
        c
      );
      o.push({
        commit: c,
        resource: p
      }), i = p, t && a % 30 === 0 && (t(Math.round(a / r.length * 100)), await Rs());
    }
    return o;
  }
  async setVersion(t) {
    const e = t.resource.getPropVals();
    for (const r of this.propvals.keys())
      e.has(r) || this.remove(r);
    for (const [r, o] of e.entries())
      await this.set(r, o);
    await this.save();
  }
  /**
   * @deprecated use resource.subject
   */
  getSubject() {
    return this.subject;
  }
  /** Returns the subject URL of the Resource */
  getSubjectNoParams() {
    const t = new URL(this.subject);
    return t.origin + t.pathname;
  }
  /** Returns the internal Map of Property-Values */
  getPropVals() {
    return this.propvals;
  }
  /**
   * Iterates over the parents of the resource, returns who has read / write
   * rights for this resource
   */
  async getRights() {
    const t = [];
    this.getSubjects(U.write).forEach((i) => {
      t.push({
        for: i,
        type: "write",
        setIn: this.subject
      });
    }), this.getSubjects(U.read).forEach((i) => {
      t.push({
        for: i,
        type: "read",
        setIn: this.subject
      });
    });
    const o = this.get(U.parent);
    if (o) {
      if (o === this.subject)
        return console.warn("Circular parent", o), t;
      const a = await (await this.store.getResource(o)).getRights();
      t.push(...a);
    }
    return t;
  }
  /** Returns true is the resource had an `Unauthorized` 401 response. */
  isUnauthorized() {
    return !!this.error && gs(this.error);
  }
  /** Removes the resource form both the server and locally */
  async destroy(t) {
    if (this.new) {
      this.store.removeResource(this.subject);
      return;
    }
    const e = new ot(this.subject);
    if (e.setDestroy(true), t === void 0 && (t = this.store.getAgent()), (t == null ? void 0 : t.subject) === void 0)
      throw new Error(
        "No agent has been set or passed, you cannot delete this."
      );
    const r = await e.sign(t.privateKey, t.subject), o = new URL(this.subject).origin + "/commit";
    await this.store.postCommit(r, o), this.store.removeResource(this.subject);
  }
  /** @deprecated use `resource.push` */
  pushPropVal(t, e, r) {
    this.push(t, e, r);
  }
  /** Appends a Resource to a ResourceArray */
  push(t, e, r) {
    const o = this.get(t) ?? [];
    r && (e = e.filter((i) => !o.includes(i)).filter((i) => {
      var a;
      return !((a = this.commitBuilder.push[t]) != null && a.includes(i));
    }).filter((i, a, n) => n.indexOf(i) === a)), this.commitBuilder.addPushAction(t, ...e), this.propvals.set(t, [...o, ...e]);
  }
  /** @deprecated use `resource.remove()` */
  removePropVal(t) {
    this.remove(t);
  }
  /** Removes a property value combination from the resource and adds it to the next Commit */
  remove(t) {
    this.propvals.delete(t), this.commitBuilder.addRemoveAction(t);
  }
  /**
   * Removes a property value combination from this resource, does not store the
   * remove action in Commit
   */
  removePropValLocally(t) {
    this.propvals.delete(t);
  }
  /**
   * Commits the changes and sends the Commit to the resource's `/commit`
   * endpoint. Returns the Url of the created Commit. If you don't pass an Agent
   * explicitly, the default Agent of the Store is used.
   * When there are no changes no commit is made and the function returns Promise<undefined>.
   */
  async save(t) {
    var p, u;
    if (!this.commitBuilder.hasUnsavedChanges()) {
      console.warn(`No changes to ${this.subject}, not saving`);
      return;
    }
    const e = this.store.getAgent() ?? t;
    if (!e)
      throw new Error("No agent has been set or passed, you cannot save.");
    if (this.hasQueue)
      return;
    if (this.isParentNew()) {
      this.store.batchResource(this.subject);
      return;
    }
    if (this.inProgressCommit)
      return this.hasQueue = true, await this.inProgressCommit, this.hasQueue = false, this.inProgressCommit = void 0, this.save(t);
    const r = (p = this.get(U.commit.lastCommit)) == null ? void 0 : p.toString();
    r && this.commitBuilder.setPreviousCommit(r);
    const o = this.new;
    let i = () => {
    };
    this.inProgressCommit = new Promise((h) => {
      i = () => {
        h();
      };
    });
    const a = this.commitBuilder.clone();
    this.commitBuilder = new ot(this.subject);
    const n = await a.sign(
      e.privateKey,
      e.subject
    );
    this.appliedCommitSignatures.add(n.signature), this.loading = false, this.new = false;
    const c = new URL(this.subject).origin + "/commit";
    try {
      this.commitError = void 0, this.store.addResources(this, { skipCommitCompare: true });
      const h = await this.store.postCommit(n, c);
      return this.setUnsafe(U.commit.lastCommit, h.id), this.store.notifyResourceSaved(this), o && (this.store.subscribeWebSocket(this.subject), await this.store.saveBatchForParent(this.subject)), i(), h.id;
    } catch (h) {
      if (h.message.includes("previousCommit")) {
        console.warn("previousCommit missing or mismatch, retrying...");
        const f = (u = (await this.store.fetchResourceFromServer(
          this.subject
        )).get(U.commit.lastCommit)) == null ? void 0 : u.toString();
        return f && this.setUnsafe(U.commit.lastCommit, f), i(), await this.save(e);
      }
      throw this.commitBuilder = a, this.commitError = h, this.store.addResources(this, { skipCommitCompare: true }), i(), h;
    }
  }
  /**
   * Set a Property, Value combination and perform a validation. Will throw if
   * property is not valid for the datatype. Will fetch the datatype if it's not
   * available. Adds the property to the commitbuilder.
   *
   * When undefined is passed as value, the property is removed from the resource.
   */
  async set(t, e, r = true) {
    if (this.store.isOffline() && r && (console.warn("Offline, not validating"), r = false), r) {
      const o = await this.store.getProperty(t);
      try {
        fs(e, o.datatype);
      } catch (i) {
        throw i instanceof Error && (i.message = `Error validating ${o.shortname} with value ${e} for ${this.subject}: ${i.message}`), i;
      }
    }
    if (e === void 0) {
      this.remove(t), this.eventManager.emit("local-change", t, e);
      return;
    }
    this.propvals.set(t, e), this.commitBuilder.addSetAction(t, e), this.eventManager.emit("local-change", t, e);
  }
  /**
   * Set a Property, Value combination without performing validations or adding
   * it to the CommitBuilder.
   */
  setUnsafe(t, e) {
    this.propvals.set(t, e);
  }
  /** Sets the error on the Resource. Does not Throw. */
  setError(t) {
    this.error = t;
  }
  /** Set the Subject / ID URL of the Resource. Does not update the Store. */
  setSubject(t) {
    N.tryValidSubject(t), this.commitBuilder.setSubject(t), this._subject = t;
  }
  /** Refetches the resource from the server. Will reset all changes to the latest saved version */
  async refresh() {
    await this.store.fetchResourceFromServer(this.subject, {
      noWebSocket: true
    });
  }
  isParentNew() {
    const t = this.propvals.get(A.properties.parent);
    return t ? this.store.getResourceLoading(t).new : false;
  }
};
var Ss = ((s) => (s.READ = "read", s.WRITE = "write", s))(Ss || {});
function fr(s) {
  return s.__internalObject !== s && console.warn("Attempted to proxy a proxy for " + s.subject), new Proxy(s.__internalObject, {});
}
var Rs = () => new Promise((s) => setTimeout(s));
var J = class {
  constructor() {
    this.parsedResources = [];
  }
  /**
   * Parses an JSON-AD object containing a resource. Returns the resource and a list of all the sub-resources it found.
   */
  parseObject(t, e) {
    return this.parsedResources = [], [this.parseJsonADResource(
      t,
      e
    ), [...this.parsedResources]];
  }
  /**
   * Parses an array of JSON-AD objects containing resources.
   * Returns a list of the resources in the array and a list of all the resources that were found including sub-resources.
   */
  parseArray(t) {
    return this.parsedResources = [], [this.parseJsonADArray(t), [...this.parsedResources]];
  }
  parseValue(t, e) {
    return this.parsedResources = [], [this.parseJsonAdResourceValue(t, e), [...this.parsedResources]];
  }
  parseJsonADResource(t, e = K) {
    const r = new L(e);
    this.parsedResources.push(r);
    try {
      for (const [o, i] of Object.entries(t)) {
        if (o === "@id") {
          if (typeof i != "string")
            throw new Error("'@id' field must be a string");
          if (r.subject !== "undefined" && r.subject !== K && i !== r.subject)
            throw new Error(
              `Resource has wrong subject in @id. Received subject was ${i}, expected ${r.subject}.`
            );
          r.setSubject(i);
          continue;
        }
        try {
          if (Lt(i)) {
            const a = i.map(
              (n) => this.parseJsonAdResourceValue(n, o)
            );
            r.setUnsafe(o, a);
          } else if (typeof i == "string")
            r.setUnsafe(o, i);
          else if (typeof i == "number")
            r.setUnsafe(o, i);
          else if (typeof i == "boolean")
            r.setUnsafe(o, i);
          else {
            const a = this.parseJsonAdResourceValue(i, o);
            r.setUnsafe(o, a);
          }
        } catch (a) {
          const c = `${`Failed creating value ${i} for key ${o} in resource ${r.subject}`}. ${a.message}`;
          throw new Error(c);
        }
      }
      r.loading = false, r.hasClasses(wt.classes.error) && (r.error = j.fromResource(r));
    } catch (o) {
      throw o.message = "Failed parsing JSON " + o.message, r.setError(o), r.loading = false, o;
    }
    return r;
  }
  parseJsonAdResourceValue(t, e) {
    if (typeof t == "string")
      return t;
    if ((t == null ? void 0 : t.constructor) === {}.constructor)
      if (Object.keys(t).includes("@id")) {
        const r = t["@id"];
        return this.parseJsonADResource(t), r;
      } else
        return t;
    throw new Error(
      `Value ${t} in ${e} not a string or a nested Resource`
    );
  }
  /** Parses a JSON-AD array, returns array of Resources */
  parseJsonADArray(t) {
    const e = [];
    try {
      for (const r of t) {
        const o = this.parseJsonADResource(r);
        e.push(o);
      }
    } catch (r) {
      throw r.message = "Failed parsing JSON " + r.message, r;
    }
    return e;
  }
};
ct.sha512 = (s) => Promise.resolve(ps(s));
function zt() {
  return Math.round((/* @__PURE__ */ new Date()).getTime());
}
var ot = class _ot {
  /** Removes any query parameters from the Subject */
  constructor(t, e = {}) {
    this._subject = N.removeQueryParamsFromURL(t), this._set = e.set ?? /* @__PURE__ */ new Map(), this._push = e.push ?? /* @__PURE__ */ new Map(), this._remove = e.remove ?? /* @__PURE__ */ new Set(), this._destroy = e.destroy, this._previousCommit = e.previousCommit;
  }
  get subject() {
    return this._subject;
  }
  get set() {
    return this._set;
  }
  get push() {
    return this._push;
  }
  get remove() {
    return this._remove;
  }
  get destroy() {
    return this._destroy;
  }
  get previousCommit() {
    return this._previousCommit;
  }
  addSetAction(t, e) {
    return this.removeRemoveAction(t), this._set.set(t, e), this;
  }
  addPushAction(t, ...e) {
    const r = this._push.get(t) ?? /* @__PURE__ */ new Set();
    for (const o of e)
      r.add(o);
    return this._push.set(t, r), this;
  }
  addRemoveAction(t) {
    return this._set.delete(t), this._push.delete(t), this._remove.add(t), this;
  }
  removeRemoveAction(t) {
    return this._remove.delete(t), this;
  }
  setDestroy(t) {
    return this._destroy = t, this;
  }
  /**
   * Set the URL of the Commit that was previously (last) applied. The value of
   * this should probably be the `lastCommit` of the Resource.
   */
  setPreviousCommit(t) {
    return this._previousCommit = t, this;
  }
  setSubject(t) {
    return this._subject = t, this;
  }
  /**
   * Signs the commit using the privateKey of the Agent, and returns a full
   * Commit which is ready to be sent to an Atomic-Server `/commit` endpoint.
   */
  async sign(t, e) {
    return await this.signAt(
      e,
      t,
      zt()
    );
  }
  /** Returns true if the CommitBuilder has non-empty changes (set, remove, destroy) */
  hasUnsavedChanges() {
    return this.set.size > 0 || this.push.size > 0 || this.destroy || this.remove.size > 0;
  }
  /**
   * Creates a clone of the CommitBuilder. This is required, because I want to
   * prevent any adjustments to the CommitBuilder while signing, as this could
   * cause race conditions with wrong signatures
   */
  // Warning: I'm not sure whether this actually solves the issue. Might be a good idea to remove this.
  clone() {
    const t = {
      set: this.set,
      push: this.push,
      remove: this.remove,
      destroy: this.destroy,
      previousCommit: this.previousCommit
    };
    return new _ot(this.subject, structuredClone(t));
  }
  toPlainObject() {
    return {
      subject: this.subject,
      set: Object.fromEntries(this.set.entries()),
      push: Object.fromEntries(
        Array.from(this.push.entries()).map(([t, e]) => [t, Array.from(e)])
      ),
      remove: Array.from(this.remove),
      destroy: this.destroy,
      previousCommit: this.previousCommit
    };
  }
  /** Creates a signature for a Commit using the private Key of some Agent. */
  async signAt(t, e, r) {
    if (t === void 0)
      throw new Error("No agent passed to sign commit");
    if (!this.hasUnsavedChanges())
      throw new Error(`No changes to commit in ${this.subject}`);
    const o = {
      ...this.clone().toPlainObject(),
      createdAt: r,
      signer: t
    }, i = fe({ ...o }), a = await ge(i, e);
    return {
      ...o,
      signature: a
    };
  }
};
function D(s, t, e) {
  t in s && t !== e && (Object.defineProperty(
    s,
    e,
    Object.getOwnPropertyDescriptor(s, t)
  ), delete s[t]);
}
function fe(s) {
  return s.remove && Object.keys(s.remove).length === 0 && delete s.remove, s.set && Object.keys(s.set).length === 0 && delete s.set, s.push && Object.keys(s.push).length === 0 && delete s.push, s.destroy === false && delete s.destroy, D(s, "createdAt", b.properties.commit.createdAt), D(s, "subject", b.properties.commit.subject), D(s, "set", b.properties.commit.set), D(s, "push", b.properties.commit.push), D(s, "signer", b.properties.commit.signer), D(s, "signature", b.properties.commit.signature), D(s, "remove", b.properties.commit.remove), D(s, "destroy", b.properties.commit.destroy), D(s, "previousCommit", b.properties.commit.previousCommit), s[b.properties.isA] = [b.classes.commit], Ke(s);
}
var ge = async (s, t) => {
  const e = ce(t), r = new Uint8Array(e), i = new TextEncoder().encode(s), a = await ze(i, r);
  return bt(a);
};
var As = async (s) => {
  const t = ce(s), e = new Uint8Array(t), r = await ne(e);
  return bt(r);
};
async function gr() {
  const s = ct.randomPrivateKey(), t = await ne(s), e = bt(s);
  return {
    publicKey: bt(t),
    privateKey: e
  };
}
function xs(s) {
  return {
    id: s.getSubject(),
    subject: s.get(b.properties.commit.subject),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    set: s.get(b.properties.commit.set),
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    push: s.get(b.properties.commit.push),
    signer: s.get(b.properties.commit.signer),
    createdAt: s.get(b.properties.commit.createdAt),
    remove: s.get(b.properties.commit.remove),
    destroy: s.get(b.properties.commit.destroy),
    signature: s.get(b.properties.commit.signature)
  };
}
function ye(s) {
  try {
    const t = JSON.parse(s);
    if (typeof t != "object")
      throw new Error("Commit is not an object");
    const e = t[b.properties.commit.subject], r = t[b.properties.commit.set], o = t[b.properties.commit.push], i = t[b.properties.commit.signer], a = t[b.properties.commit.createdAt], n = t[b.properties.commit.remove], c = t[b.properties.commit.destroy], p = t[b.properties.commit.signature], u = t["@id"], h = t[b.properties.commit.previousCommit];
    if (!p)
      throw new Error("Commit has no signature");
    return {
      subject: e,
      set: r,
      push: o,
      signer: i,
      createdAt: a,
      remove: n,
      destroy: c,
      signature: p,
      id: u,
      previousCommit: h
    };
  } catch (t) {
    throw new Error(`Could not parse commit: ${t}, Commit: ${s}`);
  }
}
function be(s, t) {
  const { set: e, remove: r, push: o } = t;
  return e && Cs(e, s), r && js(r, s), o && Ps(o, s), s;
}
function Es(s, t) {
  const e = ye(s), { subject: r, id: o, destroy: i, signature: a } = e;
  let n = t.resources.get(r);
  if (!n)
    n = new L(r);
  else if (n.appliedCommitSignatures.has(a))
    return;
  if (n = be(n, e), o && n.setUnsafe(U.commit.lastCommit, o), i) {
    t.removeResource(r);
    return;
  } else
    n.appliedCommitSignatures.add(a), t.addResources(n, { skipCommitCompare: true });
}
function Cs(s, t, e) {
  const r = new J(), o = [];
  for (const [i, a] of Object.entries(s)) {
    let n = a;
    if ((a == null ? void 0 : a.constructor) === {}.constructor) {
      const [c, p] = r.parseValue(a, i);
      n = c, o.push(...p);
    }
    Lt(a) && (n = a.map((c) => {
      const [p, u] = r.parseValue(c, i);
      return o.push(...u), p;
    })), t.setUnsafe(i, n);
  }
}
function js(s, t) {
  for (const e of s)
    t.removePropValLocally(e);
}
function Ps(s, t, e) {
  const r = new J(), o = [];
  for (const [i, a] of Object.entries(s)) {
    const n = t.get(i) || [], p = a.map((h) => {
      const [l, f] = r.parseValue(h, i);
      return o.push(...f), l;
    }), u = [...n, ...p];
    t.setUnsafe(i, u);
  }
}
async function we(s, t) {
  const e = zt();
  if (!t.subject)
    throw new Error("Agent has no subject, cannot authenticate");
  return {
    "https://atomicdata.dev/properties/auth/agent": t.subject,
    "https://atomicdata.dev/properties/auth/requestedSubject": s,
    "https://atomicdata.dev/properties/auth/publicKey": await t.getPublicKey(),
    "https://atomicdata.dev/properties/auth/timestamp": e,
    "https://atomicdata.dev/properties/auth/signature": await ve(
      s,
      t,
      e
    )
  };
}
async function ve(s, t, e) {
  const r = `${s} ${e}`;
  return await ge(r, t.privateKey);
}
function Us(s, t) {
  var e;
  return !s.startsWith("http://localhost") && ((e = t == null ? void 0 : t.subject) == null ? void 0 : e.startsWith("http://localhost"));
}
async function Qt(s, t, e) {
  const r = zt();
  return t != null && t.subject && !Us(s, t) && (e["x-atomic-public-key"] = await t.getPublicKey(), e["x-atomic-signature"] = await ve(
    s,
    t,
    r
  ), e["x-atomic-timestamp"] = r, e["x-atomic-agent"] = t == null ? void 0 : t.subject), e;
}
var _s = 24 * 60 * 60 * 1e3;
var Ns = (s, t, e, r = _s) => {
  const o = new Date(Date.now() + r).toUTCString(), i = encodeURIComponent(t), a = new URL(e).hostname, n = `${s}=${i};Expires=${o};Domain=${a};SameSite=Lax;path=/`;
  document.cookie = n;
};
var Se = "atomic_session";
var Re = (s, t) => {
  we(s, t).then((e) => {
    Ns(Se, btoa(JSON.stringify(e)), s);
  });
};
var Bs = () => {
  const s = document.cookie.match(
    /^(.*;)?\s*atomic_session\s*=\s*[^;]+(.*)?$/
  );
  return s ? s.length > 0 : false;
};
var Os = () => {
  document.cookie = `${Se}=;Max-Age=-99999999`;
};
var ks = (s) => "blob" in s && "name" in s;
var Fs = "application/ad+json";
var N = class _N {
  constructor(t) {
    t && this.setFetch(t);
  }
  /** Throws an error if the subject is not valid */
  static tryValidSubject(t) {
    try {
      new URL(t);
    } catch (e) {
      throw new Error(`Not a valid URL: ${t}. ${e}`);
    }
  }
  /** Returns true if the given subject is valid */
  static isValidSubject(t) {
    if (typeof t != "string") return false;
    try {
      return _N.tryValidSubject(t), true;
    } catch {
      return false;
    }
  }
  /**
   * Removes query params from the URL if it can build a URL. Will return the
   * normal URL if things go wrong.
   */
  // TODO: Not sure about this. Was done because `new Commit()` failed with `unknown-subject`.
  static removeQueryParamsFromURL(t) {
    return t == null ? void 0 : t.split("?")[0];
  }
  setFetch(t) {
    this.__fetchOverride = t.bind(globalThis);
  }
  /**
   * Fetches and Parses a Resource. Can fetch through another atomic server if you
   * pass the `from` argument, which should be the baseURL of an Atomic Server.
   * Returns a tuple of the requested resource and a list of all resources found in the response.
   */
  async fetchResourceHTTP(t, e = {}) {
    const { signInfo: r, from: o, body: i, method: a } = e;
    let n = [];
    const c = new J();
    let p = new L(t);
    try {
      _N.tryValidSubject(t);
      const u = {};
      u.Accept = Fs, r && (ft() && t.startsWith(window.location.origin) ? Bs() || Re(r.serverURL, r.agent) : await Qt(t, r.agent, u));
      let h = t;
      if (o !== void 0) {
        const m = new URL(`${o}/path`);
        m.searchParams.set("path", t), h = m.href;
      }
      const l = await this.fetch(h, {
        headers: u,
        method: a ?? "GET",
        body: i
      }), f = await l.text();
      if (l.status === 200)
        try {
          const m = JSON.parse(f);
          if (e.noNested)
            p = m;
          else {
            const [y, S] = c.parseObject(
              m,
              t
            );
            p = y, n.push(...S);
          }
        } catch (m) {
          throw new j(
            `Could not parse JSON from fetching ${t}. Is it an Atomic Data resource? Error message: ${m.message}`
          );
        }
      else throw l.status === 401 ? new j(f, et.Unauthorized) : l.status === 500 ? new j(f, et.Server) : l.status === 404 ? new j(f, et.NotFound) : new j(f);
    } catch (u) {
      p.setError(u), n = [p], console.error(t, u);
    }
    return p.loading = false, { resource: p, createdResources: n };
  }
  /** Posts a Commit to some endpoint. Returns the Commit created by the server. */
  async postCommit(t, e) {
    const r = fe({ ...t }), o = new Headers();
    o.set("Content-Type", "application/ad+json");
    let i;
    try {
      i = await this.fetch(e, {
        headers: o,
        method: "POST",
        body: r
      });
    } catch (n) {
      throw new j(`Posting Commit to ${e} failed: ${n}`);
    }
    const a = await i.text();
    if (i.status !== 200)
      throw new j(a, et.Server);
    return ye(a);
  }
  /**
   * Uploads files to the `/upload` endpoint of the Store. Signs the Headers using
   * the given agent.
   * Returns the newly created resources
   */
  async uploadFiles(t, e, r, o) {
    const i = new J(), a = new FormData();
    t.map((m) => {
      ks(m) ? a.append("assets", m.blob, m.name) : a.append("assets", m, m.name);
    });
    const n = new URL(`${e}/upload`);
    n.searchParams.set("parent", o);
    const c = await Qt(n.toString(), r, {}), p = {
      method: "POST",
      body: a,
      headers: c
    }, u = await this.fetch(n.toString(), p), h = await u.text();
    if (u.status !== 200)
      throw Error(h);
    const l = JSON.parse(h), [f] = i.parseArray(l);
    return f;
  }
  fetch(...t) {
    return this.__fetchOverride ? this.__fetchOverride(...t) : fetch(...t);
  }
};
var Ae = class _Ae {
  constructor(t, e) {
    if (e && N.tryValidSubject(e), !t)
      throw new j("Agent requires a private key");
    this.client = new N(), this.subject = e, this.privateKey = t;
  }
  /**
   * Parses a base64 JSON object containing a privateKey and subject, and
   * constructs an Agent from that.
   */
  static fromSecret(t) {
    const e = atob(t), r = JSON.parse(e), { privateKey: o, subject: i } = r;
    return new _Ae(o, i);
  }
  /** Returns public key or generates one using the private key */
  async getPublicKey() {
    if (!this.publicKey) {
      const t = await As(this.privateKey);
      this.publicKey = t;
    }
    return this.publicKey;
  }
  /**
   * Returns a base64 encoded JSON object containing the Subject and the Private
   * Key. Used for signing in with one string
   */
  buildSecret() {
    const t = JSON.stringify(this);
    return btoa(t);
  }
  /** Fetches the public key for the agent, checks if it matches with the current one */
  async verifyPublicKeyWithServer() {
    var r;
    if (!this.subject)
      throw new j("Agent has no subject");
    const { resource: t } = await this.client.fetchResourceHTTP(this.subject);
    if (t.error)
      throw new Error(
        `Could not fetch agent, and could therefore not check validity of public key. ${t.error}`
      );
    if (((r = t.get(A.properties.publicKey)) == null ? void 0 : r.toString()) !== await this.getPublicKey())
      throw new Error(
        "Fetched publickey does not match current one - is the private key correct?"
      );
  }
};
var xe = (s) => {
  const t = new URL(s);
  return t.pathname = "search", t;
};
var Ts = [
  "+",
  "^",
  "`",
  ":",
  "{",
  "}",
  '"',
  "[",
  "]",
  "(",
  ")",
  "!",
  "\\",
  "*",
  " ",
  // The dot is escaped, even though it's not in Tantivy's list.
  "."
];
function Is(s) {
  return s.replace(
    new RegExp(`([${Ts.join("\\")}])`, "g"),
    "\\$1"
  );
}
function Ms(s) {
  return Object.entries(s).map(([t, e]) => e && `${Is(t)}:"${e}"`).join(" AND ");
}
function $s(s, t, e = {}) {
  const { include: r = false, limit: o = 30, parents: i, filters: a } = e, n = xe(s), c = a && Object.keys(a).length > 0 && Object.values(a).filter((p) => p && p.length > 0).length > 0;
  return t && n.searchParams.set("q", t), r && n.searchParams.set("include", r.toString()), o && n.searchParams.set("limit", o.toString()), c && n.searchParams.set("filters", Ms(a)), i && (Array.isArray(i) ? n.searchParams.append("parents", i.join(",")) : n.searchParams.append("parents", i)), n.toString();
}
function yr(s) {
  const t = xe(s.getServerUrl()).toString(), e = s.clientSideQuery(
    (r) => r.subject !== t && r.subject.startsWith(t)
  );
  for (const r of e)
    s.removeResource(r.subject);
}
function Nt(s) {
  if (!Ht(s))
    throw new Error("Parameter was not an error");
}
function Ht(s) {
  return !!s && typeof s == "object" && Ds(s) === "[object Error]" || s instanceof Error;
}
function Ds(s) {
  return Object.prototype.toString.call(s);
}
var Ls = "Layerr";
var Ws = Ls;
function zs() {
  return Ws;
}
function Hs(s) {
  let t, e = "";
  if (s.length === 0)
    t = {};
  else if (Ht(s[0]))
    t = {
      cause: s[0]
    }, e = s.slice(1).join(" ") || "";
  else if (s[0] && typeof s[0] == "object")
    t = Object.assign({}, s[0]), e = s.slice(1).join(" ") || "";
  else if (typeof s[0] == "string")
    t = {}, e = e = s.join(" ") || "";
  else
    throw new Error("Invalid arguments passed to Layerr");
  return {
    options: t,
    shortMessage: e
  };
}
var T = class _T extends Error {
  constructor(t, e) {
    const r = [...arguments], { options: o, shortMessage: i } = Hs(r);
    let a = i;
    if (o.cause && (a = `${a}: ${o.cause.message}`), super(a), this.message = a, o.name && typeof o.name == "string" ? this.name = o.name : this.name = zs(), o.cause && Object.defineProperty(this, "_cause", { value: o.cause }), Object.defineProperty(this, "_info", { value: {} }), o.info && typeof o.info == "object" && Object.assign(this._info, o.info), Error.captureStackTrace) {
      const n = o.constructorOpt || this.constructor;
      Error.captureStackTrace(this, n);
    }
  }
  static cause(t) {
    return Nt(t), t._cause && Ht(t._cause) ? t._cause : null;
  }
  static fullStack(t) {
    Nt(t);
    const e = _T.cause(t);
    return e ? `${t.stack}
caused by: ${_T.fullStack(e)}` : t.stack ?? "";
  }
  static info(t) {
    Nt(t);
    const e = {}, r = _T.cause(t);
    return r && Object.assign(e, _T.info(r)), t._info && Object.assign(e, t._info), e;
  }
  toString() {
    let t = this.name || this.constructor.name || this.constructor.prototype.name;
    return this.message && (t = `${t}: ${this.message}`), t;
  }
};
var Ee = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var it = 32;
var te = 281474976710655;
var Vs = 10;
var Ks = 16;
var st = Object.freeze({
  source: "ulid"
});
function Gs(s) {
  const t = Js(), e = t && (t.crypto || t.msCrypto) || null;
  if (typeof (e == null ? void 0 : e.getRandomValues) == "function")
    return () => {
      const r = new Uint8Array(1);
      return e.getRandomValues(r), r[0] / 255;
    };
  if (typeof (e == null ? void 0 : e.randomBytes) == "function")
    return () => e.randomBytes(1).readUInt8() / 255;
  throw new T({
    info: {
      code: "PRNG_DETECT",
      ...st
    }
  }, "Failed to find a reliable PRNG");
}
function Js() {
  return Ys() ? self : typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : null;
}
function qs(s, t) {
  let e = "";
  for (; s > 0; s--)
    e = Xs(t) + e;
  return e;
}
function Zs(s, t) {
  if (isNaN(s))
    throw new T({
      info: {
        code: "ENC_TIME_NAN",
        ...st
      }
    }, `Time must be a number: ${s}`);
  if (s > te)
    throw new T({
      info: {
        code: "ENC_TIME_SIZE_EXCEED",
        ...st
      }
    }, `Cannot encode a time larger than ${te}: ${s}`);
  if (s < 0)
    throw new T({
      info: {
        code: "ENC_TIME_NEG",
        ...st
      }
    }, `Time must be positive: ${s}`);
  if (Number.isInteger(s) === false)
    throw new T({
      info: {
        code: "ENC_TIME_TYPE",
        ...st
      }
    }, `Time must be an integer: ${s}`);
  let e, r = "";
  for (let o = t; o > 0; o--)
    e = s % it, r = Ee.charAt(e) + r, s = (s - e) / it;
  return r;
}
function Ys() {
  return typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
}
function Xs(s) {
  let t = Math.floor(s() * it);
  return t === it && (t = it - 1), Ee.charAt(t);
}
function Qs(s, t) {
  const e = Gs(), r = isNaN(s) ? Date.now() : s;
  return Zs(r, Vs) + qs(Ks, e);
}
function tr(s) {
  return s.toLowerCase().replace(/\s+/g, "-").replace(/-+/g, "-").replace(/[^\w-]+/g, "");
}
function ee(s, t) {
  const e = new URL(s);
  e.protocol === "http:" ? e.protocol = "ws" : e.protocol = "wss", e.pathname = "/ws";
  const r = new WebSocket(e.toString());
  return r.onopen = (o) => er(t, r), r.onmessage = (o) => sr(o, t), r.onerror = rr, r;
}
function er(s, t) {
  Ft(t, s).then(() => {
    for (const e of s.subscribers.keys())
      s.subscribeWebSocket(e);
  });
}
function sr(s, t) {
  if (s.data.startsWith("COMMIT ")) {
    const e = s.data.slice(7);
    Es(e, t);
  } else if (s.data.startsWith("ERROR "))
    t.notifyError(s.data.slice(6));
  else if (s.data.startsWith("RESOURCE ")) {
    const e = Ce(s);
    t.addResources(e);
  } else
    console.warn("Unknown websocket message:", s);
}
function rr(s) {
  console.error("websocket error:", s);
}
function Ce(s) {
  const t = s.data.slice(9), e = JSON.parse(t), r = new J(), [o, i] = r.parseObject(e);
  return i;
}
async function Ft(s, t, e = false) {
  var i;
  const r = t.getAgent();
  if (!r || !r.subject)
    return;
  if (!s.url.startsWith("ws://localhost") && ((i = r == null ? void 0 : r.subject) != null && i.startsWith("http://localhost"))) {
    console.warn(
      `Can't authenticate localhost Agent over websocket with remote server ${s.url} because the server will nog be able to retrieve your Agent and verify your public key.`
    );
    return;
  }
  const o = await we(s.url, r);
  s.send("AUTHENTICATE " + JSON.stringify(o)), e && t.resources.forEach((a) => {
    (a.isUnauthorized() || a.loading) && t.fetchResourceFromServer(a.subject);
  });
}
var se = 5e3;
async function or(s, t) {
  return new Promise((e, r) => {
    s.addEventListener("message", function o(i) {
      const a = setTimeout(() => {
        s.removeEventListener("message", o), r(
          new Error(
            `Request for subject "${t}" timed out after ${se}ms.`
          )
        );
      }, se);
      i.data.startsWith("RESOURCE ") && Ce(i).forEach((n) => {
        n.subject === t && (clearTimeout(a), s.removeEventListener("message", o), e(n));
      });
    }), s.send("GET " + t);
  });
}
var ir = ((s) => (s.ResourceSaved = "resource-saved", s.ResourceRemoved = "resource-removed", s.ResourceManuallyCreated = "resource-manually-created", s.AgentChanged = "agent-changed", s.ServerURLChanged = "server-url-changed", s.Error = "error", s))(ir || {});
var Bt = () => typeof WebSocket < "u";
var br = class {
  constructor(t = {}) {
    this.batchedResources = /* @__PURE__ */ new Map(), this.eventManager = new ue(), this._resources = /* @__PURE__ */ new Map(), this.webSockets = /* @__PURE__ */ new Map(), this.subscribers = /* @__PURE__ */ new Map(), t.serverUrl && this.setServerUrl(t.serverUrl), t.agent && this.setAgent(t.agent), this.client = new N(this.injectedFetch), this.getAgent = this.getAgent.bind(this), this.setAgent = this.setAgent.bind(this);
  }
  /** All the resources of the store */
  get resources() {
    return this._resources;
  }
  /** Inject a custom fetch implementation to use when fetching resources over http */
  injectFetch(t) {
    this.injectedFetch = t, this.client.setFetch(t);
  }
  addResources(t, e) {
    for (const r of Array.isArray(t) ? t : [t])
      this.addResource(r, e ?? {});
  }
  /**
   * @deprecated Will be marked private in the future, please use `addResources`
   *
   * Adds a Resource to the store and notifies subscribers. Replaces existing
   * resources, unless this new resource is explicitly incomplete.
   */
  addResource(t, { skipCommitCompare: e }) {
    if (t.setStore(this), t.get(A.properties.incomplete)) {
      const r = this.resources.get(t.subject);
      if (r && !r.loading)
        return;
    }
    if (!e) {
      const r = this.resources.get(t.subject);
      if (r && !r.hasClasses(Tt.classes.collection) && !r.loading && !r.new && r.get(Ot.properties.lastCommit) === t.get(Ot.properties.lastCommit))
        return;
    }
    this.resources.set(t.subject, t.__internalObject), this.notify(t.__internalObject);
  }
  /**
   * A helper function for creating new resources.
   * Options take:
   * subject (optional) - defaults to random subject,
   * parent (optional) - defaults to serverUrl,
   * isA (optional),
   * properties (optional) - any additional properties to be set on the resource.
   */
  async newResource({
    subject: t,
    parent: e,
    isA: r,
    propVals: o,
    noParent: i
  } = {}) {
    const a = Array.isArray(r) ? r : [r], n = t ?? this.createSubject(), c = this.getResourceLoading(n, { newResource: true });
    if (a[0] && await c.addClasses(...a), i || await c.set(A.properties.parent, e ?? this.serverUrl), o)
      for (const [p, u] of Object.entries(o))
        await c.set(p, u);
    return c;
  }
  async search(t, e = {}) {
    const r = $s(this.serverUrl, t, e);
    return (await this.fetchResourceFromServer(r, {
      noWebSocket: true
    })).get(wt.properties.results) ?? [];
  }
  /** Checks if a subject is free to use */
  async checkSubjectTaken(t) {
    var r;
    const e = this.resources.get(t);
    if (e != null && e.isReady() && !(e != null && e.new))
      return true;
    try {
      const o = this.agent ? { agent: this.agent, serverURL: this.getServerUrl() } : void 0, { createdResources: i } = await this.client.fetchResourceHTTP(
        t,
        {
          method: "GET",
          signInfo: o
        }
      );
      if ((r = i.find((a) => a.subject === t)) != null && r.isReady())
        return true;
    } catch {
    }
    return false;
  }
  /**
   * Checks is a set of URL parts can be combined into an available subject.
   * Will retry until it works.
   */
  async buildUniqueSubjectFromParts(t, e) {
    const r = t.map((i) => tr(i)).join("/"), o = e ?? this.getServerUrl();
    return this.findAvailableSubject(r, o);
  }
  /** Creates a random subject url. You can pass a parent subject if you want that to be included in the url. */
  createSubject(t) {
    return t ? `${t}/${this.randomPart()}` : new URL(`/${this.randomPart()}`, this.serverUrl).toString();
  }
  /**
   * Always fetches resource from the server then adds it to the store.
   */
  async fetchResourceFromServer(t, e = {}) {
    if (e.setLoading) {
      const o = new L(t);
      o.loading = true, this.addResources(o, { skipCommitCompare: true });
    }
    const r = this.getWebSocketForSubject(t);
    if (!e.fromProxy && !e.noWebSocket && Bt() && (r == null ? void 0 : r.readyState) === WebSocket.OPEN)
      await or(r, t);
    else {
      const o = this.agent ? { agent: this.agent, serverURL: this.getServerUrl() } : void 0, { createdResources: i } = await this.client.fetchResourceHTTP(
        t,
        {
          from: e.fromProxy ? this.getServerUrl() : void 0,
          method: e.method,
          body: e.body,
          signInfo: o
        }
      );
      this.addResources(i, { skipCommitCompare: true });
    }
    return this.resources.get(t);
  }
  getAllSubjects() {
    return Array.from(this.resources.keys());
  }
  /** Returns the WebSocket for the current Server URL */
  getDefaultWebSocket() {
    return this.webSockets.get(this.getServerUrl());
  }
  /** Opens a Websocket for some subject URL, or returns the existing one. */
  getWebSocketForSubject(t) {
    const e = new URL(t), r = this.webSockets.get(e.origin);
    if (r)
      return r;
    typeof window < "u" && this.webSockets.set(e.origin, ee(e.origin, this));
  }
  /** Returns the base URL of the companion server */
  getServerUrl() {
    return this.serverUrl;
  }
  /**
   * Returns the Currently set Agent, returns null if there is none. Make sure
   * to first run `store.setAgent()`.
   */
  getAgent() {
    return this.agent ?? void 0;
  }
  /**
   * Gets a resource by URL. Fetches and parses it if it's not available in the
   * store. Instantly returns an empty loading resource, while the fetching is
   * done in the background . If the subject is undefined, an empty non-saved
   * resource will be returned.
   */
  getResourceLoading(t = K, e = {}) {
    if (t === K || t === null) {
      const o = new L(K, e.newResource);
      return o.setStore(this), o;
    }
    let r = this.resources.get(t);
    if (r)
      !e.allowIncomplete && r.loading === false && r.get(A.properties.incomplete) && (r.loading = true, this.addResources(r), this.fetchResourceFromServer(t, e));
    else return r = new L(t, e.newResource), r.loading = true, this.addResources(r), e.newResource || this.fetchResourceFromServer(t, e), r;
    return r;
  }
  /**
   * @deprecated
   * renamed to `getResource`
   */
  async getResourceAsync(t) {
    return this.getResource(t);
  }
  /**
   * Gets a resource by URL. Fetches and parses it if it's not available in the
   * store. Not recommended to use this for rendering, because it might cause
   * resources to be fetched multiple times.
   */
  async getResource(t) {
    const e = this.resources.get(t);
    if (e && e.isReady())
      return e;
    if (e && !e.isReady())
      return new Promise((o, i) => {
        const n = (c) => {
          this.unsubscribe(t, n), o(c);
        };
        this.subscribe(t, n), setTimeout(() => {
          this.unsubscribe(t, n), i(
            new Error(
              `Async Request for subject "${t}" timed out after 5000ms.`
            )
          );
        }, 5e3);
      });
    const r = await this.fetchResourceFromServer(t);
    return this.subscribeWebSocket(t), r;
  }
  /** Gets a property by URL. */
  async getProperty(t) {
    var c;
    const e = await this.getResource(t);
    if (e === void 0)
      throw Error(`Property ${t} is not found`);
    if (e.error)
      throw Error(`Property ${t} cannot be loaded: ${e.error}`);
    const r = e.get(A.properties.datatype);
    if (r === void 0)
      throw Error(
        `Property ${t} has no datatype: ${e.getPropVals()}`
      );
    const o = e.get(A.properties.shortname);
    if (o === void 0)
      throw Error(
        `Property ${t} has no shortname: ${e.getPropVals()}`
      );
    const i = e.get(A.properties.description);
    if (i === void 0)
      throw Error(
        `Property ${t} has no description: ${e.getPropVals()}`
      );
    const a = (c = e.get(A.properties.classtype)) == null ? void 0 : c.toString();
    return {
      subject: t,
      classType: a,
      shortname: o.toString(),
      description: i.toString(),
      datatype: us(r.toString()),
      allowsOnly: e.get(A.properties.allowsOnly)
    };
  }
  /**
   * This is called when Errors occur in some of the library functions.
   */
  notifyError(t) {
    const e = t instanceof Error ? t : new Error(t);
    if (this.eventManager.hasSubscriptions(
      "error"
      /* Error */
    ))
      this.eventManager.emit("error", e);
    else
      throw e;
  }
  /**
   * If the store does not have an active internet connection, will return
   * false. This may affect some functionality. For example, some checks will
   * not be performed client side when offline.
   */
  isOffline() {
    var t;
    return ft() ? !((t = window == null ? void 0 : window.navigator) != null && t.onLine) : false;
  }
  async notifyResourceSaved(t) {
    await this.eventManager.emit("resource-saved", t);
  }
  async notifyResourceManuallyCreated(t) {
    await this.eventManager.emit("resource-manually-created", t);
  }
  /** Parses the HTML document for `JSON-AD` data in <meta> tags, adds it to the store */
  parseMetaTags() {
    const t = document.querySelectorAll(
      'meta[property="json-ad-initial"]'
    ), e = new J();
    t.forEach((r) => {
      const o = r.getAttribute("content");
      if (o === null)
        return;
      const i = JSON.parse(atob(o)), [a, n] = e.parseObject(i);
      this.addResources(n);
    });
  }
  /**
   * Fetches all Classes and Properties from your current server, including external resources.
   * This helps to speed up time to interactive, but may not be necessary for all applications.
   */
  async preloadPropsAndClasses() {
    const t = new URL("/classes", this.serverUrl), e = new URL("/properties", this.serverUrl);
    t.searchParams.set("include_external", "true"), e.searchParams.set("include_external", "true"), t.searchParams.set("include_nested", "true"), e.searchParams.set("include_nested", "true"), t.searchParams.set("page_size", "999"), e.searchParams.set("page_size", "999"), await Promise.all([
      this.fetchResourceFromServer(t.toString()),
      this.fetchResourceFromServer(e.toString())
    ]);
  }
  /** Sends an HTTP POST request to the server to the Subject. Parses the returned Resource and adds it to the store. */
  async postToServer(t, e) {
    return this.fetchResourceFromServer(t, {
      body: e,
      noWebSocket: true,
      method: "POST"
    });
  }
  /** Removes (destroys / deletes) resource from this store */
  removeResource(t) {
    const e = this.resources.get(t);
    e && (this.resources.delete(t), this.eventManager.emit("resource-removed", e));
  }
  /**
   * Changes the Subject of a Resource. Checks if the new name is already taken,
   * errors if so.
   */
  async renameSubject(t, e) {
    N.tryValidSubject(e);
    const r = t.subject;
    if (await this.checkSubjectTaken(e))
      throw Error(`New subject name is already taken: ${e}`);
    t.setSubject(e);
    const o = this.subscribers.get(r) ?? [];
    this.subscribers.set(e, o), this.removeResource(r), this.addResources(t);
  }
  /**
   * Sets the current Agent, used for signing commits. Authenticates all open
   * websockets, and retries previously failed fetches.
   *
   * Warning: doing this stores the Private Key of the Agent in memory. This
   * might have security implications for your application.
   */
  setAgent(t) {
    this.agent = t, t && t.subject ? (ft() && Re(this.serverUrl, t), this.webSockets.forEach((e) => {
      e.readyState === e.OPEN ? Ft(e, this, true) : e.onopen = () => {
        Ft(e, this, true);
      };
    })) : ft() && Os(), this.eventManager.emit("agent-changed", t);
  }
  /** Sets the Server base URL, without the trailing slash. */
  setServerUrl(t) {
    if (N.tryValidSubject(t), t.substring(-1) === "/")
      throw Error("baseUrl should not have a trailing slash");
    this.serverUrl = t, this.eventManager.emit("server-url-changed", t), Bt() && this.openWebSocket(t);
  }
  /** Opens a WebSocket for this Atomic Server URL */
  openWebSocket(t) {
    if (Bt()) {
      if (this.webSockets.has(t))
        return;
      this.webSockets.set(t, ee(t, this));
    } else
      console.warn("WebSockets not supported, no window available");
  }
  /**
   * Registers a callback for when the a resource is updated. When you call
   * this
   * The method returns a function that you can call to unsubscribe. You can also unsubscribe by calling `store.unsubscribe()`.
   */
  // TODO: consider subscribing to properties, maybe add a second subscribe function, use that in useValue
  subscribe(t, e) {
    if (t === void 0)
      throw Error("Cannot subscribe to undefined subject");
    let r = this.subscribers.get(t);
    return r === void 0 && (this.subscribeWebSocket(t), r = []), r.push(e), this.subscribers.set(t, r), () => {
      this.unsubscribe(t, e);
    };
  }
  subscribeWebSocket(t) {
    if (t !== K)
      try {
        const e = this.getWebSocketForSubject(t);
        (e == null ? void 0 : e.readyState) === 1 && (e == null || e.send(`SUBSCRIBE ${t}`));
      } catch (e) {
        console.error(e);
      }
  }
  unSubscribeWebSocket(t) {
    var e;
    if (t !== K)
      try {
        (e = this.getDefaultWebSocket()) == null || e.send(`UNSUBSCRIBE ${t}`);
      } catch (r) {
        console.error(r);
      }
  }
  /** Unregisters the callback (see `subscribe()`) */
  unsubscribe(t, e) {
    if (t === void 0)
      return;
    let r = this.subscribers.get(t);
    r && (r = r == null ? void 0 : r.filter((o) => o !== e), this.subscribers.set(t, r));
  }
  on(t, e) {
    return this.eventManager.register(t, e);
  }
  /** Uploads files to atomic server and create resources for them, then returns the subjects.
   * If using this in Node.js and it does not work, try injecting node-fetch using `Store.injectFetch()` Some versions of Node create mallformed FormData when using the build-in fetch.
   */
  async uploadFiles(t, e) {
    const r = this.getAgent();
    if (!r)
      throw Error("No agent set, cannot upload files");
    const o = await this.client.uploadFiles(
      t,
      this.getServerUrl(),
      r,
      e
    );
    return this.addResources(o), o.map((i) => i.subject);
  }
  /** Posts a Commit to some endpoint. Returns the Commit created by the server. */
  async postCommit(t, e) {
    return this.client.postCommit(t, e);
  }
  /**
   * Returns the ancestry of a resource, starting with the resource itself.
   */
  async getResourceAncestry(t) {
    const e = [t.subject];
    let r = t.get(A.properties.parent);
    for (r && e.push(r); r; ) {
      const o = await this.getResource(r);
      if (o) {
        if (r = o.get(A.properties.parent), e.includes(r))
          throw new Error(
            `Resource ${t.subject} ancestry is cyclical. ${r} is already in the ancestry}`
          );
        e.push(r);
      }
    }
    return e;
  }
  /**
   * Returns a list of resources currently in the store which pass the given filter function.
   * This is a client-side filter, and does not query the server.
   */
  clientSideQuery(t) {
    return Array.from(this.resources.values()).filter(t);
  }
  /**
   * @Internal
   * Add the resource to a batch that is saved when the parent is saved. Only gets saved when the parent is new.
   */
  batchResource(t) {
    const e = this._resources.get(t);
    if (!e)
      throw new Error(
        `Resource ${t} can not be saved because it is not in the store.`
      );
    const r = e.get(A.properties.parent);
    if (r === void 0)
      throw new Error(
        `Resource ${t} can not be added to a batch because it's missing a parent.`
      );
    this.batchedResources.has(r) ? this.batchedResources.get(r).add(t) : this.batchedResources.set(r, /* @__PURE__ */ new Set([t]));
  }
  /**
   * @Internal
   * Saves all resources that are in a batch for a parent.
   */
  async saveBatchForParent(t) {
    const e = this.batchedResources.get(t);
    if (e) {
      for (const r of e) {
        const o = this._resources.get(r);
        await (o == null ? void 0 : o.save());
      }
      this.batchedResources.delete(t);
    }
  }
  async importJsonAD(t, e) {
    const r = new URL(me.import, this.serverUrl);
    r.searchParams.set("parent", e.parent), r.searchParams.set(
      "overwrite-outside",
      e.overwriteOutside ? "true" : "false"
    );
    const o = await this.postToServer(r.toString(), t);
    if (o.error)
      throw o.error;
  }
  randomPart() {
    return Qs().toLowerCase();
  }
  async findAvailableSubject(t, e, r = true) {
    let o = new URL(`${e}/${t}`).toString();
    if (!r) {
      const a = this.randomPart();
      o += `-${a}`;
    }
    return await this.checkSubjectTaken(o) ? this.findAvailableSubject(t, e, false) : o;
  }
  /** Lets subscribers know that a resource has been changed. Time to update your views.
   * Make sure the resource is a new reference, otherwise React will not rerender.
   */
  async notify(t) {
    const e = t.subject, r = this.subscribers.get(e);
    r !== void 0 && Promise.allSettled(r.map(async (o) => o(t)));
  }
};
function wr(s, t, e) {
  let r = s.replace(/(^\w+:|^)\/\//, "");
  if (typeof window < "u" && (window != null && window.location) && r.startsWith(window.location.hostname) && (r = r.slice(window.location.hostname.length)), r.length <= t)
    return r;
  if (e) {
    const o = r.length - t;
    return "..." + r.slice(o);
  }
  return r.slice(0, t) + "...";
}
Ne();

// node_modules/@tomic/react/dist/src/hooks.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function useResource(subject, opts) {
  if (subject === void 0) {
    subject = K;
  }
  var store = useStore();
  var _a = __read((0, import_react.useState)(function() {
    return store.getResourceLoading(subject, opts);
  }), 2), resource = _a[0], setResource = _a[1];
  (0, import_react.useEffect)(function() {
    setResource(fr(store.getResourceLoading(subject, opts)));
    return store.subscribe(subject, function(updated) {
      setResource(fr(updated));
    });
  }, [store, subject]);
  return resource;
}
var stableEmptyArray = [];
function useResources(subjects, opts) {
  if (subjects === void 0) {
    subjects = stableEmptyArray;
  }
  if (opts === void 0) {
    opts = {};
  }
  var _a = __read((0, import_react.useState)(/* @__PURE__ */ new Map()), 2), resources = _a[0], setResources = _a[1];
  var store = useStore();
  (0, import_react.useEffect)(function() {
    function handleNotify(updated) {
      setResources(function(prev) {
        prev.set(updated.getSubject(), fr(updated));
        return new Map(prev);
      });
    }
    setResources(function(prev) {
      var e_1, _a2;
      try {
        for (var subjects_1 = __values2(subjects), subjects_1_1 = subjects_1.next(); !subjects_1_1.done; subjects_1_1 = subjects_1.next()) {
          var subject = subjects_1_1.value;
          var resource = store.getResourceLoading(subject, opts);
          prev.set(subject, fr(resource));
          store.subscribe(subject, handleNotify);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (subjects_1_1 && !subjects_1_1.done && (_a2 = subjects_1.return)) _a2.call(subjects_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return new Map(prev);
    });
    return function() {
      var e_2, _a2;
      try {
        for (var subjects_2 = __values2(subjects), subjects_2_1 = subjects_2.next(); !subjects_2_1.done; subjects_2_1 = subjects_2.next()) {
          var subject = subjects_2_1.value;
          store.unsubscribe(subject, handleNotify);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (subjects_2_1 && !subjects_2_1.done && (_a2 = subjects_2.return)) _a2.call(subjects_2);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    };
  }, [subjects, store]);
  return resources;
}
function useProperty(subject) {
  var resource = useResource(subject);
  var property = (0, import_react.useMemo)(function() {
    if (resource.loading) {
      return {
        subject,
        datatype: pe.UNKNOWN,
        shortname: "loading",
        description: "Loading property ".concat(subject),
        loading: true
      };
    }
    if (resource.error) {
      return {
        subject,
        datatype: pe.UNKNOWN,
        shortname: "error",
        description: "Error getting Property. " + resource.error.message,
        error: resource.error
      };
    }
    return {
      subject,
      datatype: us(resource.props.datatype),
      shortname: resource.props.shortname,
      description: resource.props.description,
      classType: resource.props.classtype,
      isDynamic: !!resource.props.isDynamic,
      allowsOnly: resource.props.allowsOnly
    };
  }, [resource]);
  return property;
}
function useValue(resource, propertyURL, opts) {
  var _this = this;
  if (opts === void 0) {
    opts = {};
  }
  var _a = opts.commit, commit = _a === void 0 ? false : _a, _b = opts.validate, validate = _b === void 0 ? true : _b, _c = opts.commitDebounce, commitDebounce = _c === void 0 ? 100 : _c, handleValidationError = opts.handleValidationError;
  var _d = __read((0, import_react.useState)(resource.get(propertyURL)), 2), val = _d[0], set = _d[1];
  var _e2 = __read((0, import_react.useState)(resource), 2), prevResourceReference = _e2[0], setPrevResourceReference = _e2[1];
  var store = useStore();
  var _f = __read(useDebouncedCallback(function() {
    if (!commit) {
      return;
    }
    resource.save().catch(function(e) {
      return store.notifyError(e);
    });
  }, commitDebounce, [resource, store]), 1), saveResource = _f[0];
  var validateAndSet = (0, import_react.useCallback)(function(newVal) {
    return __awaiter(_this, void 0, void 0, function() {
      var e_3;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (newVal === void 0) {
              resource.remove(propertyURL);
              set(void 0);
              saveResource();
              return [
                2
                /*return*/
              ];
            }
            set(newVal);
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, resource.set(propertyURL, newVal, validate)];
          case 2:
            _a2.sent();
            saveResource();
            handleValidationError === null || handleValidationError === void 0 ? void 0 : handleValidationError(void 0);
            return [3, 4];
          case 3:
            e_3 = _a2.sent();
            if (handleValidationError) {
              handleValidationError(e_3);
            } else {
              store.notifyError(e_3);
            }
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [resource, handleValidationError, store, validate, saveResource]);
  if (resource !== prevResourceReference) {
    try {
      set(resource.get(propertyURL));
    } catch (e) {
      store.notifyError(e);
    }
    setPrevResourceReference(resource);
  }
  (0, import_react.useEffect)(function() {
    return resource.on(vs.LocalChange, function(prop, value) {
      if (prop === propertyURL) {
        set(value);
      }
    });
  }, [resource, propertyURL]);
  return [val, validateAndSet];
}
function useString(resource, propertyURL, opts) {
  var _a = __read(useValue(resource, propertyURL, opts), 2), val = _a[0], setVal = _a[1];
  if (typeof val === "string") {
    return [val, setVal];
  }
  if (val === void 0) {
    return [void 0, setVal];
  }
  return [lr(val), setVal];
}
var noNestedSupport = "error:no_support_for_editing_nested_resources_yet";
function useSubject(resource, propertyURL, opts) {
  var _a = __read(useValue(resource, propertyURL, opts), 2), val = _a[0], setVal = _a[1];
  if (!val) {
    return [void 0, setVal];
  }
  if (typeof val === "string") {
    return [val, setVal];
  } else {
    return [noNestedSupport, setVal];
  }
}
var titleHookOpts = {
  commit: true
};
function useTitle(resource, truncateLength, opts) {
  if (truncateLength === void 0) {
    truncateLength = 40;
  }
  if (opts === void 0) {
    opts = titleHookOpts;
  }
  var _a = __read(useString(resource, b.properties.name, opts), 2), name = _a[0], setName = _a[1];
  var _b = __read(useString(resource, b.properties.shortname, opts), 2), shortname = _b[0], setShortname = _b[1];
  var _c = __read(useString(resource, b.properties.file.filename, opts), 2), filename = _c[0], setFileName = _c[1];
  if (resource.loading) {
    return ["...", setName];
  }
  if (name !== void 0) {
    return [name, setName];
  }
  if (shortname !== void 0) {
    return [shortname, setShortname];
  }
  if (filename !== void 0) {
    return [filename, setFileName];
  }
  var subject = resource === null || resource === void 0 ? void 0 : resource.getSubject();
  if (typeof subject === "string" && subject.length > 0) {
    return [wr(subject, truncateLength), setName];
  }
  return [subject, setName];
}
function useArray(resource, propertyURL, opts) {
  var _a = __read(useValue(resource, propertyURL, opts), 2), value = _a[0], set = _a[1];
  var stableEmptyResourceArray = (0, import_react.useRef)([]);
  var values = (0, import_react.useMemo)(function() {
    if (value === void 0) {
      return stableEmptyResourceArray.current;
    }
    try {
      return _t(value);
    } catch (e) {
      console.error(e, value, propertyURL, resource.subject);
      return stableEmptyResourceArray.current;
    }
  }, [value, resource, propertyURL]);
  var push = (0, import_react.useCallback)(function(val) {
    resource.push(propertyURL, val);
    if (opts === null || opts === void 0 ? void 0 : opts.commit) {
      resource.save();
    }
  }, [resource, propertyURL]);
  return [values, set, push];
}
function useNumber(resource, propertyURL, opts) {
  var _a = __read(useValue(resource, propertyURL, opts), 2), value = _a[0], set = _a[1];
  if (value === void 0) {
    return [void 0, set];
  }
  return [ur(value), set];
}
function useBoolean(resource, propertyURL, opts) {
  var _a = __read(useValue(resource, propertyURL, opts), 2), value = _a[0], set = _a[1];
  (0, import_react.useEffect)(function() {
    if (value === void 0) {
      set(false);
    }
  }, [value, set]);
  if (value === void 0) {
    return [false, set];
  }
  return [pr(value), set];
}
function useDate(resource, propertyURL, opts) {
  var store = useStore();
  var _a = __read(useValue(resource, propertyURL, opts), 1), value = _a[0];
  if (value === void 0) {
    return void 0;
  }
  try {
    return hr(value);
  } catch (e) {
    store.notifyError(e);
    return;
  }
}
function useStore() {
  var store = (0, import_react.useContext)(StoreContext);
  if (store === void 0) {
    throw new Error("Store is not found in react context. Have you wrapped your application in `<StoreContext.Provider value={new Store}>`?");
  }
  return store;
}
function useCanWrite(resource, agent) {
  var store = useStore();
  var _a = __read((0, import_react.useState)(false), 2), canWrite = _a[0], setCanWrite = _a[1];
  var _b = __read((0, import_react.useState)(void 0), 2), msg = _b[0], setMsg = _b[1];
  var agentStore = store.getAgent();
  (0, import_react.useEffect)(function() {
    if (agent === void 0) {
      agent = agentStore === null || agentStore === void 0 ? void 0 : agentStore.subject;
    }
    if (agent === void 0) {
      setMsg("No Agent set");
      setCanWrite(false);
      return;
    }
    if (resource.new) {
      setCanWrite(true);
      setMsg(void 0);
      return;
    }
    setMsg("Checking write rights...");
    function tryCanWrite() {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, canWriteAsync, canWriteMsg;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              return [4, resource.canWrite(agent)];
            case 1:
              _a2 = __read.apply(void 0, [_b2.sent(), 2]), canWriteAsync = _a2[0], canWriteMsg = _a2[1];
              setCanWrite(canWriteAsync);
              if (canWriteAsync) {
                setMsg(void 0);
              } else {
                setMsg("You don't have write rights in this resource or its parents: " + canWriteMsg);
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    tryCanWrite();
  }, [resource, agent, agentStore === null || agentStore === void 0 ? void 0 : agentStore.subject]);
  return [canWrite, msg];
}
var StoreContext = (0, import_react.createContext)(new br());

// node_modules/@tomic/react/dist/src/useServerURL.js
var import_react2 = __toESM(require_react(), 1);
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var useServerURL = function() {
  var store = useStore();
  var _a = __read2((0, import_react2.useState)(store.getServerUrl()), 2), serverUrl = _a[0], setServerUrl = _a[1];
  var set = (0, import_react2.useCallback)(function(value) {
    if (!value) {
      return;
    }
    var newValue = "https://atomicdata.dev";
    if (N.isValidSubject(value)) {
      newValue = value;
    } else {
      store.notifyError(new Error("Invalid Server URL: ".concat(value, ", defaulting to atomicdata.dev")));
    }
    store.setServerUrl(newValue);
  }, [store]);
  (0, import_react2.useEffect)(function() {
    return store.on(ir.ServerURLChanged, setServerUrl);
  }, [store]);
  return [serverUrl, set];
};

// node_modules/@tomic/react/dist/src/useCurrentAgent.js
var import_react3 = __toESM(require_react(), 1);
var useCurrentAgent = function() {
  var store = useStore();
  var subscribe = (0, import_react3.useCallback)(function(callback) {
    return store.on(ir.AgentChanged, callback);
  }, [store]);
  var agent = (0, import_react3.useSyncExternalStore)(subscribe, store.getAgent);
  return [agent, store.setAgent];
};

// node_modules/@tomic/react/dist/src/useChildren.js
var import_react4 = __toESM(require_react(), 1);
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var useChildren = function(resource) {
  var _a = __read3((0, import_react4.useState)([]), 2), children = _a[0], setChildren = _a[1];
  (0, import_react4.useEffect)(function() {
    resource.getChildrenCollection().then(function(collection) {
      collection.getAllMembers().then(function(members) {
        setChildren(members);
      });
    });
  }, [resource]);
  return children;
};

// node_modules/@tomic/react/dist/src/useDebounce.js
var import_react5 = __toESM(require_react(), 1);
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
    if (ar2 || !(i in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
      ar2[i] = from[i];
    }
  }
  return to.concat(ar2 || Array.prototype.slice.call(from));
};
function useDebounce(value, delay) {
  var _a = __read4((0, import_react5.useState)(value), 2), debouncedValue = _a[0], setDebouncedValue = _a[1];
  (0, import_react5.useEffect)(function() {
    var handler = setTimeout(function() {
      setDebouncedValue(value);
    }, delay);
    return function() {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
}
function useDebouncedCallback(func, time, deps) {
  var _this = this;
  var timeoutId = (0, import_react5.useRef)();
  var _a = __read4((0, import_react5.useState)(false), 2), isWaiting = _a[0], setIsWaiting = _a[1];
  var memoizedFunction = (0, import_react5.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }
    var id = setTimeout(function() {
      return __awaiter2(_this, void 0, void 0, function() {
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, func.apply(void 0, __spreadArray([], __read4(args), false))];
            case 1:
              _a2.sent();
              timeoutId.current = void 0;
              setIsWaiting(false);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, time);
    setIsWaiting(true);
    timeoutId.current = id;
  }, __spreadArray(__spreadArray([], __read4(deps), false), [time, timeoutId], false));
  return [memoizedFunction, isWaiting];
}

// node_modules/@tomic/react/dist/src/useMarkdown.js
var import_react6 = __toESM(require_react(), 1);
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
};
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var hiddenProps = [
  // Shown as title
  U.name,
  U.shortname,
  U.file.filename,
  // Shown separately
  U.description,
  // Shown in rights / share menu
  U.write,
  U.read
];
function useMarkdown(resource) {
  var _a = __read5(useTitle(resource), 1), title = _a[0];
  var _b = __read5(useString(resource, b.properties.description), 1), description = _b[0];
  var _c = __read5((0, import_react6.useState)("# ".concat(title)), 2), md = _c[0], setMd = _c[1];
  var store = useStore();
  (0, import_react6.useEffect)(function() {
    function getPropValTexts() {
      return __awaiter3(this, void 0, void 0, function() {
        var propValLines, _a2, _b2, _c2, _d, prop, val, _e2, e_1_1;
        var _f, e_1, _g, _h;
        return __generator3(this, function(_j) {
          switch (_j.label) {
            case 0:
              propValLines = "";
              _j.label = 1;
            case 1:
              _j.trys.push([1, 7, 8, 13]);
              _a2 = true, _b2 = __asyncValues(resource.getPropVals());
              _j.label = 2;
            case 2:
              return [4, _b2.next()];
            case 3:
              if (!(_c2 = _j.sent(), _f = _c2.done, !_f)) return [3, 6];
              _h = _c2.value;
              _a2 = false;
              _d = __read5(_h, 2), prop = _d[0], val = _d[1];
              if (!!hiddenProps.includes(prop)) return [3, 5];
              _e2 = propValLines;
              return [4, propertyLine(prop, val, store)];
            case 4:
              propValLines = _e2 + _j.sent();
              _j.label = 5;
            case 5:
              _a2 = true;
              return [3, 2];
            case 6:
              return [3, 13];
            case 7:
              e_1_1 = _j.sent();
              e_1 = { error: e_1_1 };
              return [3, 13];
            case 8:
              _j.trys.push([8, , 11, 12]);
              if (!(!_a2 && !_f && (_g = _b2.return))) return [3, 10];
              return [4, _g.call(_b2)];
            case 9:
              _j.sent();
              _j.label = 10;
            case 10:
              return [3, 12];
            case 11:
              if (e_1) throw e_1.error;
              return [
                7
                /*endfinally*/
              ];
            case 12:
              return [
                7
                /*endfinally*/
              ];
            case 13:
              setMd("# ".concat(title) + propValLines + "\n\n" + description);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    getPropValTexts();
  }, [resource]);
  if (resource.error) {
    return resource.error.message;
  }
  return md;
}
function propertyLine(propertySubject, value, store) {
  return __awaiter3(this, void 0, void 0, function() {
    var property, valString;
    return __generator3(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, store.getProperty(propertySubject)];
        case 1:
          property = _a.sent();
          valString = value === null || value === void 0 ? void 0 : value.toString();
          switch (property.datatype) {
            case pe.ATOMIC_URL:
              valString = "[".concat(value, "](").concat(value, ")");
              break;
            case pe.RESOURCEARRAY:
              {
                valString = "";
                _t(value).map(function(item) {
                  valString = valString + "[".concat(item, "](").concat(item, "),");
                });
              }
              break;
            case pe.TIMESTAMP:
              valString = hr(value).toLocaleString();
              break;
          }
          return [2, "\n\n**".concat(property.shortname, "**: ").concat(valString)];
      }
    });
  });
}

// node_modules/@tomic/react/dist/src/useServerSearch.js
var import_react7 = __toESM(require_react(), 1);
var __read6 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var noResultsResult = {
  results: [],
  loading: false,
  error: void 0
};
var escapeFilterValue = function(value) {
  return value.replace(/[+^`:{}"[\]()!\\*\s]/gm, "\\$&");
};
function useServerSearch(query, opts) {
  var _a;
  if (opts === void 0) {
    opts = {};
  }
  var _b = opts.debounce, debounce = _b === void 0 ? 50 : _b;
  var store = useStore();
  var _c = __read6((0, import_react7.useState)([]), 2), results = _c[0], setResults = _c[1];
  var _d = __read6(useServerURL(), 1), serverURL = _d[0];
  var debouncedQuery = (_a = useDebounce(query, debounce)) !== null && _a !== void 0 ? _a : "";
  var searchSubjectURL = (0, import_react7.useMemo)(function() {
    return $s(serverURL, debouncedQuery, opts);
  }, [debouncedQuery, opts, serverURL]);
  var resource = useResource(searchSubjectURL, {
    noWebSocket: true
  });
  var _e2 = __read6(useArray(resource, b.properties.endpoint.results), 1), resultsIn = _e2[0];
  (0, import_react7.useEffect)(function() {
    if (!resource.loading && resultsIn) {
      setResults(resultsIn);
    }
  }, [
    // Prevent re-rendering if the resultsIn is the same
    resultsIn === null || resultsIn === void 0 ? void 0 : resultsIn.toString(),
    resource.loading
  ]);
  (0, import_react7.useEffect)(function() {
    return function() {
      yr(store);
    };
  }, []);
  var result = (0, import_react7.useMemo)(function() {
    return {
      results,
      loading: resource.loading,
      error: resource.error
    };
  }, [results, resource.loading, resource.error]);
  if (!query && !opts.allowEmptyQuery) {
    return noResultsResult;
  }
  return result;
}

// node_modules/@tomic/react/dist/src/useCollection.js
var import_react8 = __toESM(require_react(), 1);
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read7 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var buildCollection = function(store, server, _a, pageSize) {
  var property = _a.property, value = _a.value, sort_by = _a.sort_by, sort_desc = _a.sort_desc;
  var builder = new ys(store, server);
  property && builder.setProperty(property);
  value && builder.setValue(value);
  sort_by && builder.setSortBy(sort_by);
  sort_desc !== void 0 && builder.setSortDesc(sort_desc);
  pageSize && builder.setPageSize(pageSize);
  return builder.build();
};
function useCollection(queryFilter, _a) {
  var _this = this;
  var _b = _a === void 0 ? {
    pageSize: void 0,
    server: void 0
  } : _a, pageSize = _b.pageSize, server = _b.server;
  var _c = __read7((0, import_react8.useState)(true), 2), firstRun = _c[0], setFirstRun = _c[1];
  var store = useStore();
  var queryFilterMemo = useQueryFilterMemo(queryFilter);
  var _d = __read7((0, import_react8.useState)(function() {
    return buildCollection(store, server, queryFilterMemo, pageSize);
  }), 2), collection = _d[0], setCollection = _d[1];
  var mapAll = (0, import_react8.useCallback)(function(func) {
    var list = [];
    for (var index = 0; index < collection.totalMembers; index++) {
      list.push(func({ index, collection }));
    }
    return list;
  }, [collection]);
  (0, import_react8.useEffect)(function() {
    collection.waitForReady().then(function() {
      setCollection(dr(collection.__internalObject));
    });
  }, []);
  (0, import_react8.useEffect)(function() {
    if (firstRun) {
      setFirstRun(false);
      return;
    }
    var newCollection = buildCollection(store, server, queryFilterMemo, pageSize);
    newCollection.waitForReady().then(function() {
      setCollection(dr(newCollection.__internalObject));
    });
  }, [queryFilterMemo, pageSize, store, server]);
  var invalidateCollection = (0, import_react8.useCallback)(function() {
    return __awaiter4(_this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, collection.refresh()];
          case 1:
            _a2.sent();
            setCollection(dr(collection.__internalObject));
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [collection, store, server, queryFilter, pageSize]);
  return { collection, invalidateCollection, mapAll };
}
function useQueryFilterMemo(queryFilter) {
  return (0, import_react8.useMemo)(function() {
    return queryFilter;
  }, [
    queryFilter.property,
    queryFilter.value,
    queryFilter.sort_by,
    queryFilter.sort_desc
  ]);
}

// node_modules/@tomic/react/dist/src/useMemberFromCollection.js
var import_react9 = __toESM(require_react(), 1);
var __read8 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
function useMemberFromCollection(collection, index) {
  var _a = __read8((0, import_react9.useState)(K), 2), subject = _a[0], setSubject = _a[1];
  var resource = useResource(subject);
  (0, import_react9.useEffect)(function() {
    collection.getMemberWithIndex(index).then(function(s) {
      return s && setSubject(s);
    });
  }, [collection, index]);
  return resource;
}

// node_modules/@tomic/react/dist/src/useCollectionPage.js
var import_react10 = __toESM(require_react(), 1);
var __read9 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
function useCollectionPage(collection, page) {
  var _a = __read9((0, import_react10.useState)([]), 2), items = _a[0], setItems = _a[1];
  (0, import_react10.useEffect)(function() {
    collection.getMembersOnPage(page).then(setItems);
  }, [collection, page]);
  return items;
}

// node_modules/@tomic/react/dist/src/components/Image.js
var import_react11 = __toESM(require_react(), 1);
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __read10 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
var imageFormatsWithBasicSupport = /* @__PURE__ */ new Set([
  "image/svg+xml",
  "image/vnd.adobe.photoshop",
  "image/heif",
  "image/heif-sequence",
  "image/heic-sequence",
  "image/avif-sequence",
  "image/gif",
  "image/heic",
  "image/heif"
]);
var imageFormatsWithFullSupport = /* @__PURE__ */ new Set([
  "image/png",
  "image/jpeg",
  "image/vnd.microsoft.icon",
  "image/webp",
  "image/bmp",
  "image/tiff",
  "image/avif"
]);
var DEFAULT_SIZES = [100, 300, 500, 800, 1200, 1600, 2e3];
var Image = function(_a) {
  var subject = _a.subject, props = __rest(_a, ["subject"]);
  var resource = useResource(subject);
  var _b = __read10(useString(resource, wt.properties.mimetype), 1), mimeType = _b[0];
  if (resource.loading || resource.subject === K) {
    return null;
  }
  if (!resource.hasClasses(wt.classes.file)) {
    throw new Error("Incompatible resource class, resource is not a file");
  }
  if (mimeType === void 0) {
    return null;
  }
  if (imageFormatsWithBasicSupport.has(mimeType)) {
    return import_react11.default.createElement(BasicImage, __assign({ resource }, props));
  }
  if (!imageFormatsWithFullSupport.has(mimeType)) {
    throw new Error("Incompatible or missing mime-type: " + mimeType);
  }
  return import_react11.default.createElement(ImageInner, __assign({ resource }, props));
};
var ImageInner = function(_a) {
  var resource = _a.resource, sizeIndication = _a.sizeIndication, _b = _a.quality, quality = _b === void 0 ? 60 : _b, props = __rest(_a, ["resource", "sizeIndication", "quality"]);
  var _c = __read10(useString(resource, wt.properties.downloadUrl), 1), downloadUrl = _c[0];
  var toSrcSet = buildSrcSet(downloadUrl !== null && downloadUrl !== void 0 ? downloadUrl : "");
  return import_react11.default.createElement(
    "picture",
    null,
    import_react11.default.createElement("source", { srcSet: toSrcSet("avif", quality, DEFAULT_SIZES), type: "image/avif", sizes: indicationToSizes(sizeIndication), height: resource.props.imageHeight, width: resource.props.imageWidth }),
    import_react11.default.createElement("source", { srcSet: toSrcSet("webp", quality, DEFAULT_SIZES), type: "image/webp", sizes: indicationToSizes(sizeIndication), height: resource.props.imageHeight, width: resource.props.imageWidth }),
    import_react11.default.createElement("img", __assign({ src: downloadUrl }, props, { height: resource.props.imageHeight, width: resource.props.imageWidth }))
  );
};
var BasicImage = function(_a) {
  var resource = _a.resource, _sizeIndication = _a.sizeIndication, _quality = _a.quality, props = __rest(_a, ["resource", "sizeIndication", "quality"]);
  var _b = __read10(useString(resource, wt.properties.downloadUrl), 1), downloadUrl = _b[0];
  return import_react11.default.createElement("img", __assign({ src: downloadUrl }, props));
};
var indicationToSizes = function(indication) {
  if (indication === void 0) {
    return "100vw";
  }
  if (typeof indication === "number" || typeof indication === "string") {
    return parseUnit(indication);
  }
  return Object.entries(indication).map(function(_a) {
    var _b = __read10(_a, 2), key = _b[0], value = _b[1];
    return key === "default" ? parseUnit(value) : "(max-width: ".concat(key, ") ").concat(parseUnit(value));
  }).join(", ");
};
var parseUnit = function(unit) {
  return typeof unit === "number" ? "".concat(unit, "vw") : unit;
};
var toUrl = function(base, format, quality, width) {
  var url = new URL(base);
  var queryParams = new URLSearchParams();
  format && queryParams.set("f", format);
  width && queryParams.set("w", width.toString());
  quality && queryParams.set("q", quality.toString());
  url.search = queryParams.toString();
  return url.toString();
};
var buildSrcSet = function(base) {
  return function(format, quality, sizes) {
    return sizes.map(function(size) {
      return "".concat(toUrl(base, format, quality, size), " ").concat(size, "w");
    }).join(", ");
  };
};
export {
  Ae as Agent,
  j as AtomicError,
  N as Client,
  Wt as Collection,
  ys as CollectionBuilder,
  ot as CommitBuilder,
  pe as Datatype,
  et as ErrorType,
  Image,
  J as JSONADParser,
  L as Resource,
  vs as ResourceEvents,
  Ss as RightType,
  br as Store,
  StoreContext,
  ir as StoreEvents,
  ar as __INTERNAL_GET_KNOWN_SUBJECT_MAPPING,
  be as applyCommitToResource,
  $s as buildSearchSubject,
  Bs as checkAuthenticationCookie,
  bs as classes,
  Tt as collections,
  Ot as commits,
  A as core,
  we as createAuthentication,
  _e as dataBrowser,
  us as datatypeFromUrl,
  ws as datatypes,
  me as endpoints,
  escapeFilterValue,
  Is as escapeTantivyKey,
  gr as generateKeyPair,
  As as generatePublicKeyFromPrivate,
  Ue as getKnownNameBySubject,
  zt as getTimestampNow,
  le as instances,
  Lt as isArray,
  cr as isAtomicError,
  he as isNumber,
  Q as isString,
  gs as isUnauthorized,
  noNestedSupport,
  Es as parseAndApplyCommit,
  ye as parseCommitJSON,
  xs as parseCommitResource,
  U as properties,
  dr as proxyCollection,
  fr as proxyResource,
  Pe as registerOntologies,
  yr as removeCachedSearchResults,
  Os as removeCookieAuthentication,
  nr as reverseDatatypeMapping,
  fe as serializeDeterministically,
  wt as server,
  Re as setCookieAuthentication,
  Qt as signRequest,
  ge as signToBase64,
  ve as signatureMessage,
  wr as truncateUrl,
  K as unknownSubject,
  b as urls,
  useArray,
  useBoolean,
  useCanWrite,
  useChildren,
  useCollection,
  useCollectionPage,
  useCurrentAgent,
  useDate,
  useDebounce,
  useDebouncedCallback,
  useMarkdown,
  useMemberFromCollection,
  useNumber,
  useProperty,
  useResource,
  useResources,
  useServerSearch,
  useServerURL,
  useStore,
  useString,
  useSubject,
  useTitle,
  useValue,
  _t as valToArray,
  pr as valToBoolean,
  hr as valToDate,
  ur as valToNumber,
  mr as valToResource,
  lr as valToString,
  fs as validateDatatype
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tomic/lib/dist/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
  (*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@tomic_react.js.map
